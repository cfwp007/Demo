package com.wwc2.dvr;

import android.annotation.SuppressLint;
import android.app.ActivityManager;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.content.BroadcastReceiver;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.database.ContentObserver;
import android.database.Cursor;
import android.databinding.DataBindingUtil;
import android.graphics.PixelFormat;
import android.graphics.Point;
import android.net.Uri;
import android.os.Binder;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;import android.os.Looper;
import android.os.Message;
import android.os.SystemClock;
import android.os.SystemProperties;
import android.support.v4.app.NotificationCompat;
import android.text.TextUtils;
import android.view.Display;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.SurfaceHolder;
import android.view.View;
import android.view.WindowManager;
import android.view.animation.Animation;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;
import com.serenegiant.usb.UVCCamera;
import com.wwc2.common_interface.Provider;
import com.wwc2.common_interface.utils.StorageDevice;
import com.wwc2.corelib.base.BaseService;
import com.wwc2.corelib.utils.log.LogUtils;
import com.wwc2.corelib.utils.timer.TimerUtils;
import com.wwc2.corelib.utils.timer.Timerable;
import com.wwc2.dvr.data.Config;
import com.wwc2.dvr.data.ConstantsData;
import com.wwc2.dvr.data.DBUtil;
import com.wwc2.dvr.data.DriveVideo;
import com.wwc2.dvr.data.DriveVideoBack;
import com.wwc2.dvr.data.DriveVideoFont;
import com.wwc2.dvr.data.RecordData;
import com.wwc2.dvr.data.Stereo;
import com.wwc2.dvr.databinding.ActivityMainBinding;
import com.wwc2.dvr.databinding.LayoutSettingBinding;
import com.wwc2.dvr.ui.DVRActivity;import com.wwc2.dvr.ui.ProgressBarWindow;
import com.wwc2.dvr.ui.filemanager.RecordFileDataBase;
import com.wwc2.dvr.ui.filemanager.RecordFileManager;
import com.wwc2.dvr.ui.filemanager.RecordFilePopWindow;
import com.wwc2.dvr.ui.filemanager.RecordFilePopWindowTest;
import com.wwc2.dvr.ui.record.CameraHandlerThread;
import com.wwc2.dvr.ui.record.RecordContract;
import com.wwc2.dvr.ui.record.RecordPresenter;
import com.wwc2.dvr.ui.reversing.ReversinPopupWindow;
import com.wwc2.dvr.ui.settings.SettingPopWindow;
import com.wwc2.dvr.utils.ClickFilter;
import com.wwc2.dvr.utils.FileUtils;
import com.wwc2.dvr.utils.SDCardUtils;
import com.wwc2.dvr.utils.SPUtils;
import com.wwc2.dvr.utils.ThreadpoolUtil;
import com.wwc2.dvr.utils.ToastUtils;
import com.wwc2.dvr.utils.Utils;
import com.wwc2.dvr_interface.DVRDefine;import java.io.File;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;public class RecordService extends BaseService implements View.OnKeyListener,
        RecordContract.V, View.OnClickListener ,ReversinPopupWindow.CheckClickListener {

    private static final String TAG = "RecordService";
    private static final int NOTIFICATION_ID = 8891;
    //Channel ID 必须保证唯一
    private static final String CHANNEL_ID = "com.wwc2.dvr.notification.channel";
    /**
     * CAMERA message.
     */
    private static final String CAMERA = "com.android.wwc2.camera";
    /**
     * 360全景
     */
    private static final String PANORAMIC = "com.wwc2.Panoramic";

    /**
     * 系统切源广播
     */
    private static final String CURRENT_PACKAGENAME = "com.wwc2.framework.action.CURRENT_PACKAGENAME"; private static final String AUTHORITY = "com.wwc2.main.provider.logic";
    private static final String ACC_STATUS = "acc_status";
    private static final String DVR_ENABLE = "dvr_support";
    private static final String CAMERA_STATUS = "camera_status";
    private final Uri uri_acc       = Uri.parse("content://" + AUTHORITY + "/" + ACC_STATUS);
    private final Uri uri_dvr       = Uri.parse("content://" + AUTHORITY + "/" + DVR_ENABLE);
    public static Uri uri_camera    = Uri.parse("content://" + AUTHORITY + "/" + CAMERA_STATUS);

    private static final String SYSTEM_DIALOG_REASON_KEY = "reason";
    private static final String SYSTEM_DIALOG_REASON_HOME_KEY = "homekey";private ProgressBarWindow progressBarWindow;
    private SettingPopWindow settingPopWindow;
    private RecordFilePopWindow filePopupWindow;
    private WindowManager wm;
    private WindowManager.LayoutParams params;
    private View floatView;
    private Binder mBinder;
    private ImageView camera_cutover;

    private static boolean mCurACCStatus = false;

    /**
     * MSG_HIDE_BOTTOM_BAR 延时隐藏底部菜单；
     */
    private int MSG_HIDE_BOTTOM_BAR = 0x101;
    private int MSG_TAKE_PICTURE = 0x102;
    private boolean isForeGround; private CameraHandlerThread mCameraThread;
    private ActivityMainBinding binding;
    //录像是否保存 false :没保存
    private boolean isSave = false;
    private boolean isShowUI = true;
    private Context mContext = null;

    //录像没开启
    private static final int MSG_VIDEO_NO_OPEN = 200;
    private ScheduledExecutorService mScheduledExecutorService = Executors.newScheduledThreadPool(1);
    private Uri caruri = Uri.parse("content://wwc2.server.provider.carinfo/sensor");/**
     * 自动检测功能标识
     * true=正在检测中，false=未检测
     */
    private boolean SYNC_CHECK_CAMERA_NODE = false;
    /**
     * Reboot状态标识
     * true=重启中，false=重启完成
     */
    private boolean SYNC_REBOOT_CAMERA = false;

    private RecordFileManager recordFileManager = null;
    private RecordFileDataBase recordFileDataBase = null;

    //重启系统标识
    private boolean REBOOT_SYSTEM = false;

    private int checkMax = 30;
    private int checkfre = 0;
    private Runnable closeCamera = new Runnable() {
        @Override
        public void run() {
            mCameraThread.close(false);
            checkAndCloseDoubleCamera();
        }
    };private void checkAndCloseDoubleCamera(){
        boolean open = false;

        int videoSettingsType = SPUtils.getVideoSettings(getContext());//0：单路0 1：单录1 2:双录
        LogUtils.d("<-----------checkAndCloseDoubleCamera----------->"  + videoSettingsType);
        if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE){
            boolean status = getCameraStatus();
            LogUtils.d("<-----------checkAndCloseDoubleCamera-----------status-->" + status);
            if (!status){
                open = mCameraThread.isCameraFrontOpened();
            }else {
                open = mCameraThread.isCameraBackOpened();
            }}else {
            open = mCameraThread.isCameraBackOpened();
        }
     /*   if (!open){
            handler.removeCallbacks(closeCamera);
            checkCameraNode();
        }*/
        LogUtils.e("checkCloseCamera...检测中..open=" + open + ",,重试=" + checkfre);
        if(open){
            handler.removeCallbacks(closeCamera);
            if(checkfre >= checkMax){  //检测失败
                checkfre = 0;
                handler.sendEmptyMessage(Config.MSG_CHECK_FAI);
            }else{
                checkfre++;
                //持续检测
                handler.postDelayed(closeCamera, 1000);
            }
        } else{
            checkfre = 0;
            handler.removeCallbacks(closeCamera);
            checkCameraNode();
        }
    }
/**
     * 开始自动检测Runnable
     */
    private void checkCameraNode(){
        new Thread(new Runnable() {
            @Override
            public void run() {
                LogUtils.e("checkCamera.....关闭完成...开始读取节点信号...");  int videoSettingsType = SPUtils.getVideoSettings(getContext());//1：单录 2:双录

//                int cameraBType = FileUtils.readNodeFile(Config.CAMERA_GET_TYPE_NODE);
                LogUtils.e("checkCamera.....关闭完成...开始读取节点信号...");
                String sub = "", main = "";
                int tSub = 0, tMain = 0;
                LogUtils.e("checkCamera.....关闭完成...DvrApplication.getPlatform()..平台版本..." + DvrApplication.getPlatform());
                if (DvrApplication.getPlatform().equals(Config.SYSTEM_PLATFORM_39)||DvrApplication.getPlatform().equals(Config.SYSTEM_PLATFORM_61)){
                    LogUtils.d("checkCameraNode00000---------->");String code =  Config.getWTDVR_STYLE();
                    LogUtils.d("checkCameraNode00000----------code: " + code);
                    if (code .equals(Config.WTDVR_STYLE_DOUBLE_CODE)){
                        LogUtils.d("checkCamera..单路平台，双芯片");
                        tMain = mCameraThread.checkMainCam();
                        cameraMainType = tMain;
                        main = Config.checkCameraTypeValue(Config.MIAN, tMain);
                        LogUtils.d(TAG, "checkCameraNode00000  tMain="+ cameraMainType +" main=" + main);

                        tSub = mCameraThread.checkSubCam();
                        cameraSubType = tSub;
                        sub = Config.checkCameraTypeValue(Config.SUB, tSub);
                        LogUtils.d(TAG, "checkCameraNode00000  tSub="+ cameraSubType +" sub=" + sub);strAutoCheckCameraText = main + "，" + sub;
                    }else if (code .equals(Config.WTDVR_STYLE_ONE_CODE)){
                        LogUtils.d("checkCamera..单路平台，单芯片");
                        tMain = mCameraThread.checkMainCam();
                        cameraMainType = tMain;
                        tSub=  10;
                        cameraSubType =  tSub;
                        main = Config.checkCameraTypeValue(Config.MIAN, tMain);
                        LogUtils.d(TAG, "checkCameraNode00000  tMain="+ cameraMainType +" main=" + main);

                        strAutoCheckCameraText = main /*+ "，" + sub*/;
                    } }else if (DvrApplication.getPlatform().equals(Config.SYSTEM_PLATFORM_63)|| DvrApplication.getPlatform().equals(Config.SYSTEM_PLATFORM_65) ){
                    if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE_1){
                        boolean status = getCameraStatus();
                        LogUtils.d("checkCameraNode1111 ------------Runnable" +status );
                        tMain = mCameraThread.checkMainCam();
                        cameraMainType = tMain;
                        tSub=  10;
                        cameraSubType =  tSub;

                        main = Config.checkCameraTypeValue(Config.MIAN, tMain);
                        strAutoCheckCameraText = main /*+ "，" + sub*/;}else if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE){
                        LogUtils.d("checkCameraNode2222---------->" + getCameraStatus());
                        LogUtils.d("checkCameraNode2222---------->" + DvrApplication.getPlatform());
                        if (!getCameraStatus()) {
                            tSub = mCameraThread.checkSubCam();
                            cameraSubType = tSub;
                            tMain= SPUtils.getInt(getContext(),Config.TMAIN,1);
                            cameraMainType = tMain;
                            sub = Config.checkCameraTypeValue(Config.SUB, tSub);
                            strAutoCheckCameraText = /*main + "，" +*/ sub;
                            SPUtils.putInt(getContext(),Config.TSUB,tSub);
                        }else {tMain = mCameraThread.checkMainCam();
                            cameraMainType = tMain;
                            tSub =  SPUtils.getInt(getContext(),Config.TSUB,18);
                            cameraSubType = tSub;
                            main = Config.checkCameraTypeValue(Config.MIAN, tMain);
                            strAutoCheckCameraText = main /*+ "，" + sub*/;
                            SPUtils.putInt(getContext(),Config.TMAIN,tMain);
                        }
                    }else if (videoSettingsType ==Config.VIDEO_SETTINGS_DOUBLE){LogUtils.d("双路自动检测Runnable" + getCameraStatus());
                        tMain = mCameraThread.checkMainCam();
                        cameraMainType = tMain;
                        main = Config.checkCameraTypeValue(Config.MIAN, tMain);


                        tSub = mCameraThread.checkSubCam();
                        cameraSubType = tSub;
                        sub = Config.checkCameraTypeValue(Config.SUB, tSub);
                        strAutoCheckCameraText = main + "，" + sub;
                    }
                } LogUtils.d(TAG, "MSG_CHECK_TIMER  tMain=" + cameraMainType + " main=" + main);
                LogUtils.d(TAG, "MSG_CHECK_TIMER  tSub=" + cameraSubType + " sub=" + sub);

                LogUtils.d("strAutoCheckCameratypeValue tMain--->" + tMain +" tSub--->"  + tSub );
                    strAutoCheckCameratypeValue = Config.checkCameraType(tMain) + Config.checkCameraType(tSub);
                LogUtils.d("strAutoCheckCameratypeValue getCameraStatus--->" + getCameraStatus());
                    if (!getCameraStatus()){
                        SPUtils.putString(getContext(),Config.STRAUTOCHECKCAMERATYPEVALUE,strAutoCheckCameratypeValue);
                    }else {
                        SPUtils.putString(getContext(),Config.STRAUTOCHECKCAMERATYPEVALUE_CAMERASTATUS,strAutoCheckCameratypeValue);
                    }LogUtils.d("strAutoCheckCameratypeValue ---------->" + strAutoCheckCameratypeValue);
                    String mainStr =   Config.getCameraTitle(Config.checkCameraType(tMain));
                    String subStr =  Config.getCameraTitle(Config.checkCameraType(tSub));
                    if (!mainStr.equals("DEF") && !subStr .equals("DEF") ){
                        SPUtils.putString(getContext(), Config.CAMERA_KEY, mainStr);
                        SPUtils.putString(getContext(),Config.CAMERA_SUB_KEY, subStr);
                        LogUtils.d("自动检测到主摄为：" + mainStr + "  副摄 ：" + subStr);
                    }
                    strAutoCheckCameratype = Config.getCameraKey(strAutoCheckCameratypeValue);
                    LogUtils.d(TAG, "MSG_CHECK_TIMER tMain=" + tMain + ",,tSub=" + tSub
                            + ",,,type=" + strAutoCheckCameratypeValue + ",,type_value=" + strAutoCheckCameratype + "\nstrAutoCheckCameraText:" + strAutoCheckCameraText ); LogUtils.e("btnCheckClick...检测完毕...!");
                handler.sendEmptyMessage(Config.MSG_CHECK_OK);
//                                setCameraInfo(2);

            }


    }).start();
    }private Handler handler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            if (MSG_HIDE_BOTTOM_BAR == msg.what) {
                if (binding.viewBottom != null) {

                } } else if (CameraHandlerThread.MSG_RECORD_STATUS == msg.what) {
                setRecordStatus((Boolean) msg.obj);
            } else if (MSG_TAKE_PICTURE == msg.what) {
                if((Integer) msg.obj!=null){
                    takePicture(false, (Integer) msg.obj);
                }else {
                    LogUtils.d("MSG_TAKE_PICTURE obj ==null");
                }

            } else if (MSG_VIDEO_NO_OPEN == msg.what) {    Toast.makeText(getContext(), getContext().getResources().getString(R.string.video_no_open),Toast.LENGTH_SHORT).show();
            }else if (Config.AUTO_CLOSE ==msg.what){
                mReversinPopupWindow.dismissPop();
            }else if (Config.MSG_CHECK_TIMER ==msg.what){
//                mCameraThread.closeBackVideo();
                LogUtils.e("btnCheckClick...开始检测!!");
                handler.post(runRemove);
                removeMessages(Config.MSG_CHECK_TIMER);handler.removeCallbacks(closeCamera);
                handler.postDelayed(closeCamera, 1000);

            } else if (Config.MSG_CHECK_OK ==msg.what){

                LogUtils.e("btnCheckClick...检测完毕...显示结果.");
                //////////////////////////////
                setCameraInfo(2); } else if (Config.MSG_CHECK_FAI ==msg.what){

                /**
                 * 当前检测界面还存在，可继续检测或取消，无需处理锁的状态，取消事件中会处理
                 */
                LogUtils.e("btnCheckClick...检测失败...");
                setCameraInfo(6);

            } else if (Config.MSG_WRITE_TIMER ==msg.what){
                removeMessages(Config.MSG_WRITE_TIMER);

                LogUtils.d(TAG, "MSG_WRITE_TIMER 保存成功..."); binding.tvCheckInfo.setText(getContext().getString(R.string.write_ok_check));


                handler.sendEmptyMessageDelayed(Config.ISAUTOCHECK_FIAG,1000);
 }else if (Config.CAMERA_REVERSING == msg.what){
                checkReversing();
            }else if (Config.START_RECORDING == msg.what){
                startRecording();
            }else if (Config.CLEARVIDEO == msg.what){
                ToastUtils.showLongSafe(getString(R.string.video_delete_str));
                //移除定时器
                handler.removeCallbacks(mHealthRun);
            }else if (Config.ISAUTOCHECK_FIAG ==msg.what){binding.layoutNosignal.setVisibility(View.GONE);
//                checkCameraNode();
                binding.layoutCheckCamera.setVisibility(View.GONE);
//                binding.rlCheckSuccess.setVisibility(View.GONE);

                SPUtils.putString(getContext(), Config.CAMERA_VALUE, strAutoCheckCameratypeValue);
                RecordData.getInstance().cameraType.setValue(strAutoCheckCameratypeValue);

                Utils.writeTextFile(strAutoCheckCameratypeValue, Config.CAMERA_360_TYPE_NODE); //开启loading
                syncLoading(true);
                mCameraThread.rebootCamera();

            }else if (Config.MSG_SYNC_OK == msg.what){ 
            syncLoading(false);
            }else if (Config.MSG_NO_SIGNAL == msg.what){

                LogUtils.d("...MSG_NO_SIGNAL...无信号...");
                binding.layoutNosignal.setVisibility(View.VISIBLE);
            }else if (Config.MSG_OK_SIGNAL == msg.what){

                LogUtils.d("...MSG_OK_SIGNAL...信号正常...");
                binding.layoutNosignal.setVisibility(View.GONE);
            }
        }
    };}else if (Config.MSG_NO_SIGNAL == msg.what){

                LogUtils.d("...MSG_NO_SIGNAL...无信号...");
                binding.layoutNosignal.setVisibility(View.VISIBLE);
            }else if (Config.MSG_OK_SIGNAL == msg.what){

                LogUtils.d("...MSG_OK_SIGNAL...信号正常...");
                binding.layoutNosignal.setVisibility(View.GONE);
            }
        }
    };private AccObserver accObserver = new AccObserver(handler);
    private DvrEnableObserver dvrObserver = new DvrEnableObserver(handler);
    private CameraObserver cameraObserver = new CameraObserver(handler);
    private float x0, y0, x1, y1, x, y;
    private LayoutSettingBinding settingBinding;
    private int videoId = 0;
    private RecordReceiver mRecordReceiver; /**
     * 广播监听
     */
    private BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            LogUtils.d(TAG, "Broadcast: " + action);

            if (CAMERA.equals(action)) { } else if (PANORAMIC.equals(action)) {
                final boolean panoramic = intent.getBooleanExtra("panoramic", false);
                LogUtils.d(TAG, " 0 PANORAMIC_CLOSE panoramic = " + panoramic);
                if (getAccState()) {//ACC ON状态才处理。
                    if (panoramic) {
                        switchReversing();
                    } else {
                        switchDVR();
                    }
                } } else if (CURRENT_PACKAGENAME.equals(action)){

                Bundle bundle = intent.getExtras();
                if (null != bundle) {
                    String packetName = bundle.getString("packagename");
                    String className = bundle.getString("classname");
                    LogUtils.d(TAG, "top package name = " + packetName + ", className = " + className);
                    if(packetName.equals(getPackageName())){
                        return;
                    } //倒车中，不会触发切换动作，无需检测倒车
                    if(isForeGround()){
                        //检测倒车状态
                        if (!getCameraStatus()) {
                            if(DVRActivity.mDVRActivity != null){
                                DVRActivity.mDVRActivity.finish();
                            }
                            toBackgroundWindow();
                        } else {
                            LogUtils.d(TAG, "Activity CURRENT 正在倒车中，不可退出！");
                        }
                    }
                }  }else if (action.equals(Config.ACTION_REBOOT_SYSTEM)){
                LogUtils.d(TAG, " REBOOT_SYSTEM close camera!");
                REBOOT_SYSTEM = true;
                onDestroy();
            }
        }
    };private RecordPresenter recordPresenter;

    //更新录像状态
    private void setRecordStatus(Boolean status) {
//        setSwitchCamera(false);

//        SPUtils.putBoolean(mContext,Config.SIGNAL,false);
        boolean isSignal =  SPUtils.getBoolean(getContext(),Config.SIGNAL);
        if (!isSignal) return;
        ToastUtils.showShort(status ? getString(R.string.start_recording):getString(R.string.stop_recording));
        binding.captureButton.setSelected(status);    // turn blue
        binding.captureButton.setBackgroundResource(status?R.mipmap.capture_pre :R.mipmap.capture_nor);

        LogUtils.d(TAG,"-------setRecordStatus---status=" + status);
        if(status){
            //定时检测空间
            handler.removeCallbacks(mHealthRun);
            handler.post(mHealthRun);
        }else{
            handler.removeCallbacks(mHealthRun);
        }
    }private Runnable mHealthRun = new Runnable() {
        @Override
        public void run() {
            try {
                checkRemainSpace();
                //5s检测一次
                handler.postDelayed(mHealthRun, 1000 * 30);
            }catch (Exception e){
                LogUtils.d("ScheduledExecutorService---->" + e.toString());
            }
        }
    };@Override
    public String getMessageType() {
        return DVRDefine.MODULE;
    }

    @Override
    public IBinder onBind(Intent intent) {
        String packageName = intent.getStringExtra("package");
        LogUtils.e("onBind,packageName:" + packageName);
        if (getPackageName().equals(packageName)) {
            mBinder = new LocalBinder();
        }
        if ("com.wwc2.networks".equals(packageName)) {
            LogUtils.d("-----onBind  networks----------------->");
            mBinder = new CarDvrImpl(this);
        }
        return mBinder;
    } @Override
    public boolean onUnbind(Intent intent) {
        String packageName = intent.getStringExtra("package");

        if (getDvrEnable()) {
            if ("com.wwc2.networks".equals(packageName)) {
                LogUtils.e("断开连接...onUnbind,packageName:" + packageName);
                Intent reboot = new Intent();
                reboot.setAction("com.wwc2.dvr.reboot");
                sendBroadcast(reboot);
            }
        }

        return super.onUnbind(intent);
    }@Override
    public void onCreate() {
        super.onCreate();
        // The Priority.
        final int priority = android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY;//THREAD_PRIORITY_FOREGROUND;
        // Changes the Priority of the calling Thread!
        android.os.Process.setThreadPriority(priority);
        // Changes the Priority of passed Thread (first param)
        android.os.Process.setThreadPriority(android.os.Process.myTid(), priority);

        getContentResolver().unregisterContentObserver(accObserver);
        getContentResolver().registerContentObserver(uri_acc, true, accObserver);

        getContentResolver().unregisterContentObserver(dvrObserver);
        getContentResolver().registerContentObserver(uri_dvr, true, dvrObserver); getContentResolver().unregisterContentObserver(cameraObserver);
        getContentResolver().registerContentObserver(uri_camera, true, cameraObserver);

        SYNC_CHECK_CAMERA_NODE = false;
        SYNC_REBOOT_CAMERA = false;
        LogUtils.e("RecordService onCreate...重置锁状态.");isDestroy = false;
        REBOOT_SYSTEM = false;
        mContext = this;
        //初始化SPUtils相关数据
        RecordData.getInstance().readDvrConfig(this);

        recordPresenter = new RecordPresenter();
        recordPresenter.onAttach(this);
        isSave = false;

        recordFileDataBase = RecordFileDataBase.getDataBase();
        recordFileManager = RecordFileManager.getInstance(mContext);
        recordFileDataBase.onCreate(this);

        LogUtils.e("RecordService onCreate...isDestroy=" + isDestroy
                + ",,REBOOT_SYSTEM=" + REBOOT_SYSTEM + ",,isSave=" + isSave);

        DvrApplication.setInitCamera(false); mCurACCStatus = getAccState();
        createFloatWindow();
        DvrApplication.hideSystemUI(floatView);

        IntentFilter myIntentFilter = new IntentFilter();
        myIntentFilter.addAction(CAMERA);
        myIntentFilter.addAction(PANORAMIC);
        myIntentFilter.addAction(CURRENT_PACKAGENAME);
        myIntentFilter.addAction(Config.ACTION_REBOOT_SYSTEM);

        registerReceiver(mBroadcastReceiver, myIntentFilter);mRecordReceiver = new RecordReceiver();
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
//        intentFilter.addAction(Config.ACTION_MSG_SAVE_OK);
        intentFilter.addAction(Config.FULL_TYPE);
        intentFilter.addAction(Config.SPLIT_TYPE);
        intentFilter.addAction(Config.SPLIT_TYPE_UP_DOWN);
        intentFilter.addAction(Config.ACTION_CRASH);
        intentFilter.addAction(Config.SENSOR_TYPE);
        intentFilter.addAction(Config.ACTION_EXIT_DVR);
        intentFilter.addAction(Config.ACTION_VIDEO_SETTINGS);
        registerReceiver(mRecordReceiver, intentFilter);//增加存储设备的检测
        IntentFilter deviceFilter = new IntentFilter();
        deviceFilter.addAction(Intent.ACTION_MEDIA_EJECT);
        deviceFilter.addAction(Intent.ACTION_MEDIA_MOUNTED);
        deviceFilter.addAction(Intent.ACTION_MEDIA_CHECKING);
        deviceFilter.addAction(Intent.ACTION_MEDIA_BAD_REMOVAL);
        deviceFilter.addDataScheme("file");
        registerReceiver(mDeviceReceiver, deviceFilter);

        setForegroundService();

        //通知绑定
        Intent reboot = new Intent();
        reboot.setAction("com.wwc2.dvr.reboot");
        sendBroadcast(reboot);

//        updateSensor();
        LogUtils.e("RecordService onCreate end");
    }
 public void checkRemainSpace() {
        int location = RecordData.getInstance().mutableLocation;
        long freeBytes = SDCardUtils.getFreeBytesNew(location);
        String bates = SDCardUtils.formetFileSize(freeBytes);
//        LogUtils.d("------checkRemainSpace------->" + freeBytes + " bates:" + bates);
        if (freeBytes <= SDCardUtils.MIN_CHECK_SIZE /** 1G*/) { //38351007744l){//
            LogUtils.d("------checkRemainSpace--容量小于1G---开始循环删除--->" + freeBytes + " bates:" + bates);
            boolean delFont = false;
            DriveVideoFont font = DBUtil.getFontOldestUnlockVideo();
            if (font != null) {
                if(FileUtils.fileIsExists(font.getName())){boolean f_ret = FileUtils.deleteFile(font.getName());

                    LogUtils.e("------checkRemainSpace----Font=" + font.getId()
                            + ",,name=" + font.getName() + ",,删除_f_ret=" + f_ret);

                    if(f_ret){
                        DBUtil.deleteDriveFontVideoByName(font.getName());
                    }
                }else{
                    LogUtils.e("---11---checkRemainSpace--Font--name=" + font.getName()
                            + ",,文件不存在，清理数据库，继续...");
                    delFont = true;
                    DBUtil.deleteDriveFontVideoByName(font.getName());
                }
            }
 boolean delBack = false;
            DriveVideoBack back = DBUtil.getBackOldestUnlockVideo();
            if (back != null) {
                if(FileUtils.fileIsExists(back.getName())){
                    boolean b_ret = FileUtils.deleteFile(back.getName());

                    LogUtils.e("------checkRemainSpace----Back=" + back.getId()
                            + ",,name=" + back.getName() + ",,删除_b_ret=" + b_ret);

                    if(b_ret){
                        DBUtil.deleteDriveBackVideoByName(back.getName());
                    }
                }else{
                    LogUtils.e("---22---checkRemainSpace--Back--name=" + back.getName()
                            + ",,文件不存在，清理数据库，继续...");
                    delBack = true;
                    DBUtil.deleteDriveBackVideoByName(back.getName());
                }
            }//同步清理前、后记录。
            if(delFont || delBack){
                LogUtils.e("---33--同步数据库---checkRemainSpace--delFont=" + delFont
                        + ",,delBack=" + delBack);

                //无需执行，等下次调用
//                checkRemainSpace();
                LogUtils.d("------checkRemainSpace-111--无需执行，等下次调用--");
                return;
            }

            LogUtils.d("------checkRemainSpace-------font=" + font + ",,back=" + back); //没有数据
            if (font == null && back == null) {
                //有可能查询数据失败，再次检测
                //剩余1G就开始删除，预留250m的空间，到250m的警戒线停止。
                long freeBytes2 = SDCardUtils.getFreeBytesNew(location);
                if (freeBytes2 <= SDCardUtils.MIN_REMAIN_SIZE) {

                    String bates2 = SDCardUtils.formetFileSize(freeBytes2);
                    LogUtils.d("---00---checkRemainSpace-------freeBytes2=" + freeBytes2 + ",,bates2=" + bates2);

                    //提示
                    handler.sendEmptyMessage(Config.CLEARVIDEO);LogUtils.d("---11---checkRemainSpace---无法继续删除---进入警戒状态,停止录像...isRecording="
                            + mCameraThread.isRecording());
                    if (mCameraThread != null && mCameraThread.isRecording()) {
                        mCameraThread.stopRecording();
                    }
                    //同步检测状态
                    mCameraThread.checkCloseRecording();
                    return; }else{

                    //无需执行，等下次调用
//                    checkRemainSpace();
                    LogUtils.d("------checkRemainSpace-222--无需执行，等下次调用--");
                }}else{
            }
        }
    }public void setForegroundService() {
        if (Build.VERSION.SDK_INT > 26) {
            //设定的通知渠道名称
            String channelName = getString(R.string.channel_name);
            //设置通知的重要程度
            int importance = NotificationManager.IMPORTANCE_HIGH;
            //构建通知渠道
            @SuppressLint("WrongConstant")
            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, channelName, importance);
            channel.setDescription("DVR record service");  //在创建的通知渠道上发送通知
            NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID);
            builder.setSmallIcon(R.drawable.ic_launcher) //设置通知图标
//                .setContentTitle(notificationTitle)//设置通知标题
//                .setContentText(notificationContent)//设置通知内容
                    .setAutoCancel(false) //用户触摸时，自动关闭
                    .setOngoing(true);//设置处于运行状态
            //向系统注册通知渠道，注册后不能改变重要性以及其他通知行为
            NotificationManager notificationManager = (NotificationManager) getSystemService(Context
                    .NOTIFICATION_SERVICE);
            notificationManager.createNotificationChannel(channel);
            //将服务置于启动状态 NOTIFICATION_ID指的是创建的通知的ID
            startForeground(NOTIFICATION_ID, builder.build());
        } else { Notification.Builder builder = new Notification.Builder(this)
                    //设置小图标
                    .setSmallIcon(R.mipmap.ic_launcher)
                    //设置通知标题
                    .setContentTitle("CameraService is running")
                    //设置通知内容
                    .setContentText("never kill me！");
            //设置通知时间，默认为系统发出通知的时间，通常不用设置
            //.setWhen(System.currentTimeMillis());
            //通过builder.build()方法生成Notification对象,并发送通知,id=1
            startForeground(NOTIFICATION_ID, builder.build());
        }
    }  private final int DEF_WIDTH = 300;
    private final int DEF_HEIGHT = 200;
    public static final int MIN_CLICK_DELAY_TIME = 50;
    private long lastClickTime = 0;

    private View.OnClickListener switchCamera = new View.OnClickListener() {
        @Override
        public void onClick(View v) {

            if(SYNC_CHECK_CAMERA_NODE || SYNC_REBOOT_CAMERA){
                LogUtils.d(TAG, "switchCamera  设置参数中,不可操作......");
                return;
            }long currentTime = Calendar.getInstance().getTimeInMillis();
            if (currentTime - lastClickTime > MIN_CLICK_DELAY_TIME) {
                lastClickTime = currentTime;
                if (mCameraThread.getIsBackPreView()) {
                    binding.cameraViewBack.setClickable(true);
                    binding.cameraViewFront.setClickable(true);
                }else {
                    binding.cameraViewBack.setClickable(false);
                    binding.cameraViewFront.setClickable(false);
                }switch (v.getId()){
                    case R.id.camera_view_front:
                        LogUtils.d(TAG, " onClick  camera_view_front!!");
                        final boolean mReversing = getCameraStatus();
                        if (!mReversing) {
                            setSwitchCamera(true);
                        }
                        break;
                    case R.id.camera_view_back:
                        LogUtils.d(TAG, " onClick  camera_view_back!!");
                        setSwitchCamera(false);
                        break;
                }
            }
        }
    };private void createFloatWindow() {
        wm = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
        params = new WindowManager.LayoutParams();

        //params.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;//这个属性会导致挂倒车不能正常显示
        params.type = WindowManager.LayoutParams.TYPE_PHONE;
        params.format = PixelFormat.TRANSPARENT; // 设置图片格式，效果为背景透明
        params.gravity = Gravity.START | Gravity.TOP;
        params.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED
                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                | WindowManager.LayoutParams.FLAG_FULLSCREEN
                | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;

        params.width = 1;
        params.height = 1;floatView = LayoutInflater.from(this).inflate(R.layout.activity_main, null);
        floatView.findViewById(R.id.camera_cutover).setOnClickListener(cameraCutover);
        binding = DataBindingUtil.bind(floatView);
        binding.setPresenter(recordPresenter);

        binding.captureButton.setEnabled(false);
        TimerUtils.setTimer(this, 1000, new Timerable.TimerListener() {
            @Override
            public void onTimer(int paramInt) {
                if (binding != null) {
                    binding.captureButton.setEnabled(true);
                }
            }
        });wm.addView(floatView, params);
       String code =  Config.getWTDVR_STYLE(); 
       Utils.writeTextFile(Config.HD  + Config.FHD, Config.CAMERA_360_TYPE_NODE);
                        RecordData.getInstance().cameraType.setValue(Config.PAL  +Config.FHD);
                        SPUtils.putString(getContext(), Config.CAMERA_VALUE, Config.PAL  +Config.FHD);
                          RecordData.getInstance().cameraType.setValue(STRAUTOCHECKCAMERATYPEVALUE);
                    saveVideoSettings(Config.VIDEO_INPUT_VALUE_MAIN_A_SUB_A,Config.VIDEO_INPUT_KEY_MAIN_A_SUB_A);
                    type =Config.VIDEO_SETTINGS_DOUBLE;
                }

            }

        }SPUtils.setVideoSettings(getContext(), type);
        Intent intent = new Intent();
        intent.putExtra(Config.VIDEO_SETTINGS,type);
        intent.setAction(Config.ACTION_VIDEO_SETTINGS);
        sendBroadcast(intent);
        mCameraThread = new CameraHandlerThread(this, "CameraThread",
                binding.cameraViewFront, binding.cameraViewBack, cameraCheckState,
                DvrApplication.getPlatform());
        mCameraThread.setMainHandler(handler);
        mCameraThread.setSurfaceCreate(Config.CHANNEL_FRONT, false);
        mCameraThread.setSurfaceCreate(Config.CHANNEL_BACK, false);
        mCameraThread.setCurAccStatus(mCurACCStatus);
        binding.cameraViewFront.setOnClickListener(switchCamera);
            binding.cameraViewFront.setClickable(true);
            binding.cameraViewFront.setLayoutParams(new RelativeLayout.LayoutParams(DEF_WIDTH, DEF_HEIGHT));
            binding.cameraViewFront.getHolder().addCallback(new SurfaceHolder.Callback() {
                @Override
                public void surfaceCreated(SurfaceHolder holder) {
                    if (mCameraThread != null) {
                        mCameraThread.setSurfaceCreate(Config.CHANNEL_FRONT, true);
                    }
                }
 @Override
                public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
                }

                @Override
                public void surfaceDestroyed(SurfaceHolder holder) {
                    //休眠时推流时不会调用createFloatWindow，加上此句会导致推流不会预览。
//                    if (mCameraThread != null) {
//                        mCameraThread.setSurfaceCreate(Config.CHANNEL_FRONT, false);
//                    }
                }
            });binding.cameraViewBack.setOnClickListener(switchCamera);
            binding.cameraViewBack.setClickable(false);
            binding.cameraViewBack.getHolder().addCallback(new SurfaceHolder.Callback() {
            @Override
            public void surfaceCreated(SurfaceHolder holder) {
                DvrApplication.setCHANNELS(Config.CHANNEL_BACK);
                if (mCameraThread != null) {
                    mCameraThread.setSurfaceCreate(Config.CHANNEL_BACK, true);
                }
            }
@Override
            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
            }

            @Override
            public void surfaceDestroyed(SurfaceHolder holder) {String acc = getContentResolver().getType(uri_acc);
                if (acc.equals("true") && !REBOOT_SYSTEM) {
                    mCameraThread.setBackPreView(false);
                    mCameraThread.rebootCamera();
                } else {
                    LogUtils.d(TAG, " 后摄预览中断...休眠状态不处理...");
                }

//                if (mCameraThread != null) {
//                    mCameraThread.setSurfaceCreate(Config.CHANNEL_BACK, false);
//                }
            }
        });
        mCameraThread.start();

        //同步检测状态
        mCameraThread.checkCloseRecording();
        /首次启动,默认在后台
        SystemProperties.set(Stereo.CAMERA_ENABLE_DISPLAY, Stereo.CAMERA_ENABLE_DISPLAY_PAUSE);

        floatView.setFocusableInTouchMode(true);
        floatView.setOnKeyListener(this);
        floatView.setOnClickListener(this);
        binding.layoutCheckCamera.getBackground().setAlpha(120);
        setCameraInfo(cameraCheckState);

        setLockStatus(RecordData.getInstance().lockState/*.getValue()*/, true);
    }
    
    public void createDvr() {

        handler.removeCallbacks(sleepOff);//关ACC 20s内看视频会卡住。
        int videoSettingsType =  SPUtils.getVideoSettings(getContext());//0:单路1 1：单录2 2:双录
        LogUtils.d("createDvr---当前视屏设置为:" + videoSettingsType);
        if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE){
            setSingleVideo();
        }else if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE_1 || videoSettingsType ==Config.VIDEO_SETTINGS_DOUBLE){
            setDoubleVideo();
        }

    }
    
    private void setSingleVideo(){
        if (mCameraThread!=null){
            LogUtils.d("mCameraThread.getIsFrontPreView1111111111 :"  + mCameraThread.getIsFrontPreView());
            if (!mCameraThread.getIsFrontPreView()) {
                LogUtils.e(TAG, "createDvr getIsFrontPreView 异常......");
                boolean resu = mCameraThread.checkCamera();
                if (resu){
                    LogUtils.d("mCameraThread ==resu" + resu);
                }else {
                    LogUtils.d("mCameraThread ==mCameraThread.open()");
                    mCameraThread.open();
                }
            }else {
                LogUtils.d("mCameraThread.getIsFrontPreView222222222222 :"  + mCameraThread.getIsFrontPreView());
            }
        }else {
            //深休时启动视图及摄像头
             reStartSurfaceView();
        }

    } private void reStartSurfaceView(){
        LogUtils.d(TAG, "createDvr 开始等待4000s");
        try {
            Thread.sleep(3000); //摄像头工作启动到正常开启后稳定的时间

        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        LogUtils.d(TAG, "createDvr 等待完成...启动dvr..");

        handler.post(new Runnable() {
            @Override
            public void run() {
                LogUtils.d(TAG, "createDvr 状态不正常，可重启");
                createFloatWindow();
            }
        });
    }
    private void setDoubleVideo(){
        if (mCameraThread != null) {
            LogUtils.d(TAG, "createDvr mCameraThread.getIsBackPreView()" + mCameraThread.getIsBackPreView());
            if (!mCameraThread.getIsBackPreView()) {
                LogUtils.d(TAG, "createDvr checkCamera!");
                boolean resu = mCameraThread.checkCamera();
                LogUtils.d(TAG, "createDvr resu!" + resu);
                if (resu) {
                    LogUtils.d("mCameraThread ==resu" + resu);
                } else {
                    LogUtils.e(TAG, "createDvr getIsBackPreView 异常......");
                    mCameraThread.open();
                }
            }
        } else {
            reStartSurfaceView();
        }

    }
    private void setTrackView(){
        LogUtils.d("WPTAG","setTrackView query -->" +query_camera_guide_line());
        if (query_camera_guide_line()) {
            if (binding.ivTrack != null) {
                binding.ivTrack.setVisibility(View.VISIBLE);
            }
        }else {
            binding.ivTrack.setVisibility(View.GONE);
        }
    }private boolean query_camera_guide_line() {
        boolean ret = false;
        final String string = query(com.wwc2.avin_interface.Provider.CAMERA_GUIDE_LINE());
        if (!TextUtils.isEmpty(string)) {
            try {
                ret = Boolean.valueOf(string);
            } catch (NumberFormatException e) {
                e.printStackTrace();
            }
        }
        return ret;
    }
    protected String query(String name) {
        String ret = null;
        if (null != getContext()) {
            ContentResolver resolver = getContext().getContentResolver();
            if (null != resolver) {
                Cursor cursor = resolver.query(Provider.ProviderColumns.CONTENT_URI, null, null, null, null);
                if (cursor != null) {
                    if (cursor.moveToFirst()) {
                        String string = cursor.getString(cursor.getColumnIndex(name));
                        if (!TextUtils.isEmpty(string)) {
                            ret = string;
                        }
                    }
                    cursor.close();
                }
            }
        }
        return ret;
    }
     public void closeFloatView() {
        if (wm != null) {
            wm.removeView(floatView);
            wm = null;
            LogUtils.d(TAG, "closeFloatView()");
        }
//        this.stopSelf();
    } @Override
    public void onDestroy() {
        LogUtils.e(TAG, "dvr onDestroy.............");


        isDestroy = true;

        syncLoading(false);

        isForeGround = false;
        if (mCameraThread != null) {
            if (mCameraThread.isRecording()) {
                mCameraThread.stopRecording();
            }
            mCameraThread.close(false);
        }recordPresenter.onDetach();
        recordPresenter.onDestroy();

        recordFileManager.onDestory();

        DvrApplication.showSystemUI(floatView);

        closeFloatView(); if (mRecordReceiver!=null){
            unregisterReceiver(mRecordReceiver);
            mRecordReceiver = null;
        }
        try {
            unregisterReceiver(mDeviceReceiver);
        } catch (Exception e) {
            e.printStackTrace();
        }

        stopForeground(true);     
        super.onDestroy();
    }
    /**
     * 点击View时判断是否是倒车
     */
    private ReversinPopupWindow mReversinPopupWindow;
    @Override
    public void onClick(View v) {

        if(SYNC_CHECK_CAMERA_NODE || SYNC_REBOOT_CAMERA){
            LogUtils.d(TAG, "onClick  设置参数中,不可操作......");
            return;
        }boolean isReversing = getCameraStatus();
        LogUtils.d(TAG, "onClick  view... isReversing --->" + isReversing);

        if (ClickFilter.filter(400L)) {
            return;
        }
        if (isReversing){
            if (!isSave){if (mReversinPopupWindow ==null){
                    mReversinPopupWindow = new ReversinPopupWindow(getContext(),handler,this);
                }

                if (binding.layoutCheckCamera.getVisibility() !=View.VISIBLE){
                    if(!mReversinPopupWindow.isShow()){
                        mReversinPopupWindow.show(v);
                    }
                }

                isSave = false; //重置状态
                if (handler !=null){
                    handler.removeMessages(Config.AUTO_CLOSE);
                    handler.sendEmptyMessageDelayed(Config.AUTO_CLOSE,Config.DELAY_TIME);
                }
            }
            return;
        }LogUtils.d(TAG, "onClick  view...-wm=" + wm);
        if (wm != null) {
            if (binding.viewBottom.isShown()) {
                LogUtils.d(TAG, "onClick viewBottom GONE");
                binding.viewBottom.setVisibility(View.GONE);
                DvrApplication.hideSystemUI(floatView);
                stopTime();
            }else{
                LogUtils.d(TAG, "onClick viewBottom VISIBLE" + binding.viewBottom);
                binding.viewBottom.setVisibility(View.VISIBLE);
                DvrApplication.showSystemUI(floatView);
                startTime();
            }
        }
    }
/**
     * 开始自动检测popWindow
     */
    @Override
    public void checkClick() {
         if (binding.layoutCheckCamera != null) {
             setCheckUIdefault();
             mReversinPopupWindow.dismissPop();
      }
    }private void setCheckUIdefault(){
        binding.layoutCheckCamera.setVisibility(View.VISIBLE);
        binding.rlCheckSuccess.setVisibility(View.GONE);
//        if (isAutoCheck){
        binding.tvCheckInfo.setText(getContext().getString(R.string.check_warn_info_check));
//        }else {
//            binding.tvCheckInfo.setText(getContext().getString(R.string.check_warn_info));
//        }

        binding.btnCancel.setVisibility(View.VISIBLE);
        binding.btnCheck.setVisibility(View.VISIBLE);
    }private final int DEF_HIDE_UI = 5000;
    private Runnable timeRun = new Runnable() {
        @Override
        public void run() {
            if (binding.viewBottom.isShown()) {
                binding.viewBottom.setVisibility(View.GONE);
            }
            DvrApplication.hideSystemUI(floatView);
        }
    };

    private void startTime(){
        handler.removeCallbacks(timeRun);
        handler.postDelayed(timeRun, DEF_HIDE_UI);
    }private void stopTime(){
        handler.removeCallbacks(timeRun);
    }

    @Override
    public void showSettingPopWindow(View view) {
        if (settingPopWindow == null) {
            settingPopWindow = new SettingPopWindow(getContext(), onSettingsDismissListener);
        }
        settingPopWindow.show(view);

        LogUtils.d(TAG, "showSettingPopWindow...show");

        stopTime();
    }private void syncLoading(boolean isShow){
        try {
            if (isShow) {
                if (binding != null) binding.viewBottom.setVisibility(View.GONE);
                if (floatView != null) {
                    if (progressBarWindow == null) {
                        progressBarWindow = new ProgressBarWindow(getContext());
                    }
                    progressBarWindow.show(floatView);
                }
                //上限制锁
                SYNC_REBOOT_CAMERA = true;
                LogUtils.d(TAG, "syncLoading...上锁Reboot=" + SYNC_REBOOT_CAMERA);} else {
                if (progressBarWindow == null) {
                    progressBarWindow = new ProgressBarWindow(getContext());
                }
                progressBarWindow.dismiss();
                //解锁
                SYNC_REBOOT_CAMERA = false;

                LogUtils.d(TAG, "syncLoading...解锁..Reboot=" + SYNC_REBOOT_CAMERA);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    } private SettingPopWindow.OnSettingsDismissListener onSettingsDismissListener =
            new SettingPopWindow.OnSettingsDismissListener(){

        @Override
        public void onSettingsDismiss(int type) {
            LogUtils.d(TAG, "onSettingsDismiss...close...type=" + type);

            startTime();

            switch (type){case Config.CAMERA_REBOOT_PREVIEW:

                    LogUtils.d(TAG, "onSettingsDismiss..1.开始loading...功能锁住...");
                    syncLoading(true);

                    mCameraThread.rebootCamera();
                    break;
                case Config.CAMERA_REBOOT_VIDEO: if(mCameraThread.isRecording()){
                        LogUtils.d(TAG, "onSettingsDismiss..2.开始loading...功能锁住...");
                        syncLoading(true);

                        mCameraThread.rebootVideo();
                    }else{
                        LogUtils.e(TAG, "......onSettingsDismiss...没有录像，无需处理...");
                    }

                    break;
            }
        }@Override
        public void onAotuCheckListener() {

            SYNC_CHECK_CAMERA_NODE = true;
            LogUtils.e("onAotuCheckListener.....触发自动检测...上锁=SYNC_CHECK_CAMERA_NODE = "
                    + SYNC_CHECK_CAMERA_NODE);

            settingPopWindow.dismiss();
            if (wm != null) {
                if (binding.viewBottom.isShown()) {
                    binding.viewBottom.setVisibility(View.GONE);
                    DvrApplication.hideSystemUI(floatView);
                    stopTime();
                }
            }
            setCheckUIdefault();
        }@Override
                public void onMainAndSubValue(String onMainAndSubValue) {

                   LogUtils.d(TAG,"AAA 主副设置成功，值为："  +onMainAndSubValue);
                    Utils.writeTextFile(onMainAndSubValue, Config.CAMERA_360_TYPE_NODE);
                    SPUtils.putString(getContext(), Config.CAMERA_VALUE, onMainAndSubValue);
                    RecordData.getInstance().cameraType.setValue(onMainAndSubValue);

                    syncLoading(true);

                    mCameraThread.rebootCamera();

                }@Override
                public void onLocationListener() {
                    LogUtils.d("onLocationListener-");
                    if (recordFileDataBase != null && mContext != null) {
                        recordFileDataBase.onDestroy();
                        recordFileDataBase.onCreate(mContext);
                    }
                }
            };
RecordFilePopWindowTest mRecordFilePopWindowTest;

    @Override
    public void showFilePopWindow(View view) {
        if (mRecordFilePopWindowTest == null) {
            mRecordFilePopWindowTest = new RecordFilePopWindowTest(this, fileDismissListenerTest);
        }
        mRecordFilePopWindowTest.show(view, recordFileManager);   LogUtils.d(TAG, "showFilePopWindow...show");

        stopTime();
    }  
    
    private RecordFilePopWindowTest.OnFileDismissListener fileDismissListenerTest =
       
      new RecordFilePopWindowTest.OnFileDismissListener(){
        @Override
        public void onFileDismiss() {
            LogUtils.d(TAG, "onFileDismiss...close");
            startTime();
        }
    };
    @Override
    public void toBackgroundWindow() {
        LogUtils.d(TAG, "...toBackgroundWindow...SYNC_CHECK_CAMERA_NODE="
                + SYNC_CHECK_CAMERA_NODE + ",,SYNC_REBOOT_CAMERA=" + SYNC_REBOOT_CAMERA);
        if(SYNC_CHECK_CAMERA_NODE || SYNC_REBOOT_CAMERA){
            LogUtils.d(TAG, "...toBackgroundWindow...正在检测中,无需检测信号..");
        }else{
            int videoSettingsType =  SPUtils.getVideoSettings(getContext());//0:单路1 1：单录2 2:双录
            if (videoSettingsType !=Config.VIDEO_SETTINGS_SINGLE_1){
                mCameraThread.checkCamera();
            }
        }//同步录像状态
        if(!mCameraThread.isRecording()){
            mCameraThread.checkCloseRecording();
        }

        if(activitylistener != null){
            activitylistener.onBackground();
        }isForeGround = false;
        params.width = 1;
        params.height = 1;
        params.gravity = Gravity.START | Gravity.TOP;
        params.x = 0;
        params.y = 0;
        params.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED
                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                | WindowManager.LayoutParams.FLAG_FULLSCREEN
                | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;if (wm != null) {
            if (binding.viewBottom.isShown()) {
                binding.viewBottom.setVisibility(View.GONE);
            }
            wm.updateViewLayout(floatView, params);
        }
        if (null != settingPopWindow) settingPopWindow.dismiss();
        if (null != filePopupWindow) filePopupWindow.dismiss();

        binding.ivTrack.setVisibility(View.GONE); 
        SystemProperties.set(Stereo.CAMERA_ENABLE_DISPLAY, Stereo.CAMERA_ENABLE_DISPLAY_PAUSE);
        }
         @Override
    public void toForegroundWindow() {
        LogUtils.d(TAG, "...toForegroundWindow...");
        i = 100;
        if(SYNC_CHECK_CAMERA_NODE || SYNC_REBOOT_CAMERA){
            LogUtils.d(TAG, "...toForegroundWindow...正在检测中,无需检测信号..");
        }else{
            if (DvrApplication.getPlatform().equals(Config.SYSTEM_PLATFORM_61)){
                boolean isopen = mCameraThread.isCameraBackOpened();
                boolean isPreView = mCameraThread.getIsBackPreView();
                LogUtils.d("toForegroundWindow mt6761----- isopen:" + isopen +"    isPreView:" +isPreView);
                if (isopen && !isPreView) {
                    mCameraThread.rebootCamera();
                }
            }else {
                mCameraThread.checkCamera();
            }}
        int videoSettingsType =  SPUtils.getVideoSettings(getContext());//0:单录1 1：单录2 2:双录


        //同步录像状态
        if(!mCameraThread.isRecording()){
            mCameraThread.checkCloseRecording();
        }
params.width = WindowManager.LayoutParams.MATCH_PARENT;
        params.height = WindowManager.LayoutParams.MATCH_PARENT;
        params.flags = WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
                | WindowManager.LayoutParams.FLAG_FULLSCREEN
                | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;

//        if (wm != null) {
//            binding.viewBottom.setVisibility(View.VISIBLE);
            wm.updateViewLayout(floatView, params);
//        }
        isForeGround = true;//检测倒车状态
        if (!getCameraStatus()) {
//            setTrackView();
            binding.ivTrack.setVisibility(View.GONE);

            int screen = SPUtils.getSplitScreen(getContext());
            LogUtils.d(TAG, "...toForegroundWindow...screen=" + screen);

            if (screen == Config.SPLIT_SCREEN &&videoSettingsType == Config.VIDEO_SETTINGS_DOUBLE) {
                setSplitView();
            }else if (screen ==Config.SPLIT_SCREEN_UP_DOWN && videoSettingsType == Config.VIDEO_SETTINGS_DOUBLE){
                setSplitUpDownView();
            }if (DvrApplication.getPlatform().equals(Config.SYSTEM_PLATFORM_63) ||DvrApplication.getPlatform().equals(Config.SYSTEM_PLATFORM_65)){
               if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE_1){
                   setSwitchCamera(false);
               } else if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE){
                   setSwitchCamera(true);
               }
            }
        } else {
            LogUtils.d("-------------setTrackView-------------");
            setTrackView();
        }DvrApplication.hideSystemUI(floatView);
//        if(DvrApplication.getPlatform().equals(Config.SYSTEM_PLATFORM_39)){
            SystemProperties.set(Stereo.CAMERA_ENABLE_DISPLAY, Stereo.CAMERA_ENABLE_DISPLAY_SHOW);
//        }
    }public boolean isRecording() {
        if (null == mCameraThread) {
            return false;
        }
        return mCameraThread.isRecording();
    }public boolean isForeGround() {
        return isForeGround;
    }//切换倒车
    private  int i = 100;
    private void switchReversing() { 
    boolean open = mCameraThread.isCameraBackOpened();
        int is_split = SPUtils.getSplitScreen(getContext());

        LogUtils.e(TAG, "...switchReversing...open=" + open);
        int videoSettingsType = SPUtils.getVideoSettings(getContext());//1：单录 2:双录
        LogUtils.e(TAG, "...switchReversing...开始切换倒车，当前视频设置为 :" + videoSettingsType);
        LogUtils.e(TAG, "...switchReversing...开始切换倒车，当前平台为 :" + DvrApplication.getPlatform());
        if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE_1){
                if (open){ //wangp倒车
                    LogUtils.d("switchReversing..单路平台，单芯片");
                    handler.post(new Runnable() {
                        @Override
                        public void run() {

                        String STRAUTOCHECKCAMERATYPEVALUE_CAMERASTATUS =  SPUtils.getString(getContext(),Config.STRAUTOCHECKCAMERATYPEVALUE_CAMERASTATUS,"");
                        if (!TextUtils.isEmpty(STRAUTOCHECKCAMERATYPEVALUE_CAMERASTATUS)){
                            Utils.writeTextFile(STRAUTOCHECKCAMERATYPEVALUE_CAMERASTATUS, Config.CAMERA_360_TYPE_NODE); //倒车时用
                            RecordData.getInstance().cameraType.setValue(STRAUTOCHECKCAMERATYPEVALUE_CAMERASTATUS);
                            SPUtils.putString(getContext(), Config.CAMERA_VALUE, STRAUTOCHECKCAMERATYPEVALUE_CAMERASTATUS);

                        }else { Utils.writeTextFile(Config.HD  +Config.HD, Config.CAMERA_360_TYPE_NODE); //倒车时用
                            RecordData.getInstance().cameraType.setValue(Config.HD  +Config.HD);
                            SPUtils.putString(getContext(), Config.CAMERA_VALUE, Config.HD  +Config.HD);
                        }
                            saveVideoSettings(Config.VIDEO_INPUT_VALUE_MAIN_A_SUB_A,Config.VIDEO_INPUT_KEY_MAIN_A_SUB_A);
                            LogUtils.e(TAG, "...switchReversing0...getCameraStatus:" + getCameraStatus() );
                            LogUtils.e(TAG, "...switchReversing0...i=====" + i );
                            LogUtils.e(TAG, "...switchReversing0...STRAUTOCHECKCAMERATYPEVALUE_CAMERASTATUS=====" +STRAUTOCHECKCAMERATYPEVALUE_CAMERASTATUS );
                            SystemProperties.set(Config.RECORD_ENABLE, "0"); if ( i ==100 ){
                           LogUtils.e(TAG, "...switchReversing0..rebootCamera");
                           mCameraThread.rebootCamera();
                           i++;
                         }
                            LogUtils.e(TAG, "...switchReversing0...开始切换为倒车，打开摄像头并预览" );
                        }
                    });  }
            }else if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE){
                if (!open){
                    LogUtils.e(TAG, "...switchReversing1...开始切换为倒车，打开摄像头并预览" );
                    mCameraThread.openCameraBack(true);
                }
            }else if (videoSettingsType ==Config.VIDEO_SETTINGS_DOUBLE){
                LogUtils.e(TAG, "...switchReversing...开始切换倒车，当前视频设置为双录，开始检测");
                mCameraThread.checkCamera();

            }isSave = false;
        binding.viewBottom.setVisibility(View.GONE);

        if (null != settingPopWindow) settingPopWindow.dismiss();
        if (null != filePopupWindow) filePopupWindow.dismiss();

        int height = binding.cameraViewFront.getLayoutParams().height;
        int width = binding.cameraViewFront.getLayoutParams().width;
        LogUtils.d("switchReversing ...is_split=" + is_split);
        if (/*(is_split || height == -1) && (width == -1)*/(is_split == Config.SPLIT_SCREEN || is_split == Config.SPLIT_SCREEN_UP_DOWN)&& videoSettingsType == Config.VIDEO_SETTINGS_DOUBLE){
            setSwitchCamera(false);
        }if (DvrApplication.getPlatform().equals(Config.SYSTEM_PLATFORM_39) ||
                DvrApplication.getPlatform().equals(Config.SYSTEM_PLATFORM_61)) {

            preDisplay = SystemProperties.get(Stereo.CAMERA_DISPLAY);
            binding.cameraCutover.setVisibility(View.GONE);

            if (preDisplay.equals(Stereo.CAMERA_DISPLAY_SUB)) {
                LogUtils.d("单路平台双芯片，开始倒车设置底层数值");
                /////////////////////////////////////////////////////////////
                SystemProperties.set(Stereo.CAMERA_DISPLAY, Stereo.CAMERA_DISPLAY_MAIN);
            }
        } else {
            if (height == -1 && width == -1) {
                preDisplay = "SUB";
                setSwitchCamera(false);
            } else {
                preDisplay = "MAIN";
            }
        }binding.cameraViewFront.setLayoutParams(new RelativeLayout.LayoutParams(1,1));

        LogUtils.d("switchReversing ...isForeGround=" + isForeGround());
        if(!isForeGround()){
            isShowUI = isForeGround();//修改快速打倒车时会出现退出倒车后返回到DVR界面。2019-11-12
            toForegroundWindow();
        }
    }

    private void saveVideoSettings(String value,String key){
        Utils.writeTextFile(value, Config.VIDEO_SWITCH_NODE);
        SPUtils.putString(getContext(), Config.VIDEO_KEY, key);
        SPUtils.putString(getContext(), Config.VIDEO_VALUE, value);
    }
private void switchDVR() {
        LogUtils.e(TAG, "...switchDVR...检测信号...");
        int videoSettingsType =  SPUtils.getVideoSettings(getContext());//0:单录1 1：单录2 2:双录
        if(SYNC_CHECK_CAMERA_NODE || SYNC_REBOOT_CAMERA){
            LogUtils.d(TAG, "...switchDVR...正在检测中,无需检测信号..");
        }else{
            if (videoSettingsType == Config.VIDEO_SETTINGS_DOUBLE ||
                    videoSettingsType == Config.VIDEO_SETTINGS_SINGLE) {//单录时如果检测到信号马上倒车，会出现前视卡的问题。
                mCameraThread.checkCamera();
            }
        }

        LogUtils.e(TAG, "...switchDVR...isSave=" + isSave);
        if(isSave){
            handler.sendEmptyMessage(Config.ISAUTOCHECK_FIAG);
        }
        int isSplit = SPUtils.getSplitScreen(getContext());
        if (isSplit ==Config.SPLIT_SCREEN ){
            if (videoSettingsType ==Config.VIDEO_SETTINGS_DOUBLE){
                setSplitView();
            }else {
                setSwitchCamera(true);
            }
        }else if (isSplit ==Config.SPLIT_SCREEN_UP_DOWN){
            if (videoSettingsType ==Config.VIDEO_SETTINGS_DOUBLE){
                setSplitUpDownView();
            }else {
                setSwitchCamera(true);
            }}else {
            LogUtils.e(TAG, "...switchDVR...preDisplay=" + (preDisplay == null ? "null" : preDisplay));
            if (DvrApplication.getPlatform().equals(Config.SYSTEM_PLATFORM_39) ||
                    DvrApplication.getPlatform().equals(Config.SYSTEM_PLATFORM_61)) {

                String code = Config.getWTDVR_STYLE();
                if (code ==Config.WTDVR_STYLE_ONE_CODE){
                    if (preDisplay != null) {SystemProperties.set(Stereo.CAMERA_DISPLAY, preDisplay);
                        RelativeLayout.LayoutParams     m_Params = new RelativeLayout.LayoutParams(
                                RelativeLayout.LayoutParams.MATCH_PARENT,
                                RelativeLayout.LayoutParams.MATCH_PARENT);
                        binding.cameraViewBack.setZOrderOnTop(false);
                        binding.cameraViewBack.setTop(0);
                        binding.cameraViewBack.setLayoutParams(m_Params);
                        binding.cameraViewBack.setClickable(false);
                        String STRAUTOCHECKCAMERATYPEVALUE = SPUtils.getString(getContext(),Config.STRAUTOCHECKCAMERATYPEVALUE,"");if (!TextUtils.isEmpty(STRAUTOCHECKCAMERATYPEVALUE)){
                            Utils.writeTextFile(STRAUTOCHECKCAMERATYPEVALUE, Config.CAMERA_360_TYPE_NODE);
                            RecordData.getInstance().cameraType.setValue(STRAUTOCHECKCAMERATYPEVALUE);
                            SPUtils.putString(getContext(), Config.CAMERA_VALUE, STRAUTOCHECKCAMERATYPEVALUE);
                        }else {
                            Utils.writeTextFile(Config.HD  + Config.HD, Config.CAMERA_360_TYPE_NODE);
                            RecordData.getInstance().cameraType.setValue(Config.HD  + Config.HD);
                            SPUtils.putString(getContext(), Config.CAMERA_VALUE, Config.HD  + Config.HD);
                        }SystemProperties.set(Config.RECORD_ENABLE, "1");
                        saveVideoSettings(Config.VIDEO_INPUT_VALUE_MAIN_B_SUB_A,Config.VIDEO_INPUT_KEY_MAIN_B_SUB_A);
                        mCameraThread.rebootCamera();

                    }}else if(code ==Config.WTDVR_STYLE_DOUBLE_CODE){ //wangp
                    LogUtils.e(TAG, "单录双芯片取消倒车");
                    if (preDisplay != null) {
                        binding.cameraCutover.setVisibility(View.VISIBLE);
                        SystemProperties.set(Stereo.CAMERA_DISPLAY, preDisplay);
                    }
                }} else {
                if (preDisplay != null && preDisplay.equals("SUB")) {
                    binding.cameraViewFront.setLayoutParams(new RelativeLayout.LayoutParams(
                            RelativeLayout.LayoutParams.MATCH_PARENT,RelativeLayout.LayoutParams.MATCH_PARENT));
                    setSwitchCamera(true);
                } else {
                    LogUtils.d("222222222222222222222222222setSwitchCamera");
//                    binding.cameraViewFront.setLayoutParams(new RelativeLayout.LayoutParams(DEF_WIDTH, DEF_HEIGHT));
                    if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE){
                        setSwitchCamera(true);
                    }else {
                        setSwitchCamera(false);
                    }

                }
            } binding.layoutNosignal.setVisibility(View.GONE);
        binding.layoutCheckCamera.setVisibility(View.GONE);
        if (mReversinPopupWindow != null){
            mReversinPopupWindow.dismissPop();
        }

        binding.ivTrack.setVisibility(View.GONE);

        LogUtils.e(TAG, "...switchDVR...isShowUI=" + isShowUI);//false
        //aaaaaaaaaaaaaaaaaaa
        if(!isShowUI){

            toBackgroundWindow();}else{
            DvrApplication.hideSystemUI(floatView);
        }
        isShowUI = true;
        preDisplay = null;
    }private boolean getAccState() {
        String acc = getContentResolver().getType(uri_acc);
        LogUtils.e(TAG, "acc:" + acc);
        if ("true".equals(acc)) {
            return true;
        }
        return false;
    }

    private boolean getDvrEnable() {
        String dvrEnable = getContentResolver().getType(uri_dvr);
        if ("false".equals(dvrEnable)) {
            return false;
        }
        return true;
    }@Override
    public boolean onKey(View v, int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK){
            LogUtils.e(TAG, "onKey: toBackgroundWindow  isForeGround=" + isForeGround());

            //倒车中，main会拦截所有按键，无需自行处理

            if(isForeGround()) {
                LogUtils.e(TAG, "onKey: toBackgroundWindow");
                toBackgroundWindow();
            }
        }
        return false;
    } 
    int location;
    int indexBates = 0;
    @Override
    public void startRecording() {
        LogUtils.d("RecordService","---startRecording-");
         location = RecordData.getInstance().mutableLocation;
        if (!FileUtils.isDiskMounted(mContext, StorageDevice.getPath(location))) {
            if (getAccState()) {
                Toast.makeText(getContext(), getString(R.string.nodevice), Toast.LENGTH_SHORT).show();
                return;
            } else {//ACC OFF情况下未挂载，先录制到本地。2020-01-19
                location = StorageDevice.NAND_FLASH;
            }
        }
        RecordData.getInstance().recordState.setValue(true);
        handler.post(runnable);
        handler.postDelayed(runRemove, 1000  * 15);//过20秒后执行
        startTime();
    }private Runnable runnable = new Runnable() {
        @Override
        public void run() {

            LogUtils.d("RecordService","---startRecording-");
            long freeBytes = SDCardUtils.getFreeBytesNew(location);
            String bates = SDCardUtils.formetFileSize(freeBytes);
            indexBates ++;if (freeBytes <= SDCardUtils.MIN_REMAIN_SIZE /** 250m*/) {
                LogUtils.d("RecordService","----11--startRecording---可用空间不足,indexBates:"+ indexBates );
                if (index >=10 && freeBytes <= SDCardUtils.MIN_REMAIN_SIZE){
                    LogUtils.d("RecordService","----11--startRecording---可用空间不足,重复10次以上，确认无内存，提示用户,indexBates:" + indexBates );
                    ToastUtils.showShort(mContext.getString(R.string.video_delete_str));
                    //同步检测状态
                    mCameraThread.checkCloseRecording();
                }
                handler.postDelayed(runnable, 1000);
                return;
            }if (!mCameraThread.isRecording() && indexBates == 1){
                mCameraThread.startRecording();
                binding.captureButton.setBackgroundResource(R.mipmap.capture_pre);
                binding.captureButton.setSelected(true);    // turn red
            }
            handler.postDelayed(runnable, 1000);
        }
    };
 private Runnable runRemove = new Runnable() {
        @Override
        public void run() {
            indexBates = 0;
            handler.removeCallbacks(runnable);
            handler.removeCallbacks(runRemove);
        }
    }; @Override
    public void stopRecording() {
        LogUtils.d("RecordService","---stopRecording-");
        handler.post(runRemove);//取消检测逻辑
        handler.post(new Runnable() {
            @Override
            public void run() {
                binding.captureButton.setBackgroundResource(R.mipmap.capture_nor);
                startTime();
                binding.captureButton.setSelected(false);
                RecordData.getInstance().recordState.setValue(false);
            }
        });

        mCameraThread.stopRecording();
    }
    @Override
    public void onClickTakePicture(boolean isOff, final int channel) {
        LogUtils.d(TAG,"onClickTakePicture-channel-->" +channel  + " mCameraThread:" + mCameraThread  + "mCameraThread.gettakePhotoRunning:"  +
                !mCameraThread.gettakePhotoRunning(channel));
        if (mCameraThread != null && !mCameraThread.gettakePhotoRunning(channel)) {
            takePicture(isOff, channel);
        }
    }
    @Override
    public String takePicture(boolean isOff, final int channel) {

        //检测空间是否可用
        int location = RecordData.getInstance().mutableLocation;
        long freeBytes = SDCardUtils.getFreeBytesNew(location);
        int videoSettingsType = SPUtils.getVideoSettings(getContext());
        File outputFile = FileUtils.getCaptureFile(ConstantsData.PICTURE_DIR, location);
        if (outputFile == null || freeBytes == 0) {
            outputFile = FileUtils.getCaptureFile(ConstantsData.PICTURE_DIR + location, StorageDevice.NAND_FLASH);
            location = StorageDevice.NAND_FLASH;
        }
        freeBytes = SDCardUtils.getFreeBytesNew(location);
        if (freeBytes <= SDCardUtils.MIN_TAKEPICTURE_SIZE /** 5M*/) {
            handler.post(new Runnable() {
                @Override
                public void run() {
                    LogUtils.d(TAG, "takePicture 空间不足,拍照失败!");
                    ToastUtils.showShort(getResources().getString(R.string.photo_err_size));
                }
            });
            return "1000";
        }if (mCameraThread != null) {
            startTime();

            LogUtils.d(TAG, "takePicture mCameraThread=" + mCameraThread);

            if (videoSettingsType == Config.VIDEO_SETTINGS_SINGLE_1) {
                if (mCameraThread.getIsBackPreView()) {
                    LogUtils.d("单录1:开始拍照,后摄已经准备好" + channel);
                    if (outputFile == null) {
                        handler.sendMessageDelayed(handler.obtainMessage(MSG_TAKE_PICTURE), 500);
                        return "1001";
                    }
                    if (channel == Config.CHANNEL_BACK) {
                        //wpeng
                        mCameraThread.captureStill(outputFile.getPath(), channel);
                        return outputFile.getPath();} else {
                        return "1001";
                    }
                } else {
                    LogUtils.d(TAG, "单录1: takePicture mCameraThread 异常111，检测DVR!!");
                    try {
                        Thread.sleep(3000); //摄像头工作启动到正常开启后稳定的时间，解决休眠拍照前摄出现黑屏的问题。2019-11-27
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } DvrApplication.setInitCamera(true);
                    boolean resu = false;
                    LogUtils.d(TAG, "单录1: takePicture mCameraThread 开始open sleep 3s!");

                    mCameraThread.open();

                    if (outputFile != null) {
                        //开始检测是否初始化完成
                        if (channel == Config.CHANNEL_BACK) {
                            checkBackDvr(outputFile.getPath(), channel);
                            return outputFile.getPath();
                        } else {
                            return "1001";
                        }
                    } else {
                        return "1001";
                    } }
            } else {
                if (videoSettingsType == Config.VIDEO_SETTINGS_SINGLE) {

                    if (mCameraThread.isFrontOpen()) {
                        LogUtils.d("单录2:开始拍照,前摄已经准备好");
                        if (outputFile == null) {
                            handler.sendMessageDelayed(handler.obtainMessage(MSG_TAKE_PICTURE), 500);
                            return "1001";
                        }if (channel == Config.CHANNEL_FRONT) {
                            //wpeng
                            mCameraThread.captureStill(outputFile.getPath(), channel);
                            return outputFile.getPath();
                        } else {
                            return "1001";
                        }
                    } else {
                        LogUtils.d(TAG, "单录2: takePicture mCameraThread 异常111，检测DVR!!");
                        try {
                            Thread.sleep(3000); //摄像头工作启动到正常开启后稳定的时间，解决休眠拍照前摄出现黑屏的问题。2019-11-27
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
DvrApplication.setInitCamera(true);
                        LogUtils.d(TAG, "单录2: takePicture mCameraThread 开始open摄像头 sleep 3s!");

//                         mCameraThread.open();
                        mCameraThread.rebootCamera();

                        if (outputFile != null) {
                            //开始检测前摄是否初始化完成
                            if (channel == Config.CHANNEL_FRONT) {
                                LogUtils.d(TAG, "单录2: takePicture mCameraThread  拍照");
                                //wpeng
                                checkFrontDvr(outputFile.getPath(), channel);
                                return outputFile.getPath();
                            } else {
                                LogUtils.d(TAG, "单录2: takePicture mCameraThread1111111111111  拍照错误 1001");
                                return "1001";
                            }} else {
                            LogUtils.d(TAG, "单录2: takePicture mCameraThread22222222222222  拍照错误 1001");
                            return "1001";
                        }
                    }
                } else if (videoSettingsType == Config.VIDEO_SETTINGS_DOUBLE) {
                    if (mCameraThread.getIsBackPreView()) {
                        LogUtils.d("双录:开始拍照,后摄已经准备好");
                        if (outputFile == null) {
                            handler.sendMessageDelayed(handler.obtainMessage(MSG_TAKE_PICTURE), 500);
                            return "1001";
                        } //wpeng
                        mCameraThread.captureStill(outputFile.getPath(), channel);
                        return outputFile.getPath();
                    } else {

                        LogUtils.d(TAG, "双录:takePicture mCameraThread 异常222，检测DVR!!");
                        try {
                            Thread.sleep(3000); //摄像头工作启动到正常开启后稳定的时间，解决休眠拍照前摄出现黑屏的问题。2019-11-27
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        DvrApplication.setInitCamera(true);LogUtils.d(TAG, "双录: takePicture mCameraThread 开始open摄像头 sleep 3s!");
                        mCameraThread.open();

                        if (outputFile != null) {
                            LogUtils.d("takePicture outputFile !=null");
                            LogUtils.d(TAG, "双录 takePicture outputFile  =" + outputFile);
                            LogUtils.d(TAG, "双录 takePicture outputFile  getpath = " + outputFile.getPath());
                            //开始检测是否初始化完成
                            checkBackDvr(outputFile.getPath(), channel);
                            return outputFile.getPath();
                        } else {
                            LogUtils.d("takePicture outputFile ==null");
                            return "1001";
                        }
                    }
                }
            }} else {
            LogUtils.d(TAG, "takePicture 开始等待3000s");
            try {
                Thread.sleep(3000); //摄像头工作启动到正常开启后稳定的时间

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            LogUtils.d(TAG, "takePicture 等待完成...启动dvr..");

            handler.post(new Runnable() {
                @Override
                public void run() {
                    LogUtils.d(TAG, "takePicture 状态不正常，可重启");
                    createFloatWindow();
                }
            });if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE_1){
                if (channel == Config.CHANNEL_BACK){
                    LogUtils.d(TAG, "takePicture 单录1 深休拍照");
                    //wpeng
                    mCameraThread.captureStill(outputFile.getPath(), channel);
                    return outputFile.getPath();
                }else {
                    return "1001";
                }
            }else if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE){
                if (channel == Config.CHANNEL_FRONT){
                    LogUtils.d(TAG, "takePicture 单录2 深休拍照");
                    //wpeng
                    mCameraThread.captureStill(outputFile.getPath(), channel);
                    return outputFile.getPath();
                }else {
                    return "1001";
                } }else if (videoSettingsType ==Config.VIDEO_SETTINGS_DOUBLE){
                LogUtils.d(TAG, "takePicture 双录 深休拍照");
                //开始检测是否初始化完成
                checkBackDvr(outputFile.getPath(), channel);
                LogUtils.d(TAG, "takePicture 返回路径..");
                return outputFile.getPath();
            }
        }
        return "1001";
    }private int MAX = 30;
    private int index = 0;
    private void checkBackDvr(final String path, final int channel){
        handler.post(new Runnable() {
            @Override
            public void run() {
                if (mCameraThread != null) {
                    boolean backPre = mCameraThread.getIsBackPreView();
                    LogUtils.d("checkBackDvr---检查后摄---backPre=" + backPre);
                    if (backPre) {//重试
                        if (path == null) {
                            LogUtils.d("checkBackDvr-后摄--重试......");
                            handler.sendMessageDelayed(handler.obtainMessage(MSG_TAKE_PICTURE), 500);
                        }
                        //wpeng
                        mCameraThread.captureStill(path, channel);

                        //remove
                        index = 0;
                        handler.removeCallbacks(this);
                        return;
                    }
                } if(index >= MAX){
                    index = 0;
                    handler.removeCallbacks(this);
                    return;
                }
                index++;
                handler.removeCallbacks(this);
                handler.postDelayed(this, 1000);
            }
        });
    }private void checkFrontDvr(final String path, final int channel){
        handler.post(new Runnable() {
            @Override
            public void run() {
                if (mCameraThread != null) {
                    boolean backPre = mCameraThread.getIsFrontPreView();
                    LogUtils.d("checkBackDvr---检查前摄---backPre=" + backPre);
                    if (backPre) { //重试
                        if (path == null) {
                            LogUtils.d("checkBackDvr-前摄---重试......");
                            handler.sendMessageDelayed(handler.obtainMessage(MSG_TAKE_PICTURE), 500);
                        }
                        //wpeng
                        mCameraThread.captureStill(path, channel);

                        //remove
                        index = 0;
                        handler.removeCallbacks(this);
                        return;
                    }
                }LogUtils.d("checkBackDvr----隔1秒检查前摄---index=" + index);
                if(index >= MAX){
                    index = 0;
                    handler.removeCallbacks(this);
                    return;
                }
                index++;
                handler.removeCallbacks(this);
                handler.postDelayed(this, 1000);
            }
        });
    }public void doclose(){

        LogUtils.d("---test---doclose---" + mCameraThread);
        LogUtils.d("---test---doclose---" + SPUtils.getLockStatus(getContext()));
        handler.post(new Runnable() {
           @Override
           public void run() {
              //还原加锁状态
                RecordData.getInstance().lockState = SPUtils.getLockStatus(getContext());
          }
       });
        if (mCameraThread != null) {
            mCameraThread.close(false);
        }else {
            LogUtils.d("---test---mCameraThread ===null---");
        }
    }@Override
    public void setLockStatus(Boolean b, Boolean viewSet) {if (viewSet) {
            handler.post(new Runnable() {
                @Override
                public void run() {
                    if (binding != null) {
                        if (b) {
                            binding.lockButton.setBackgroundResource(R.mipmap.lock_pre);
                        } else {
                            binding.lockButton.setBackgroundResource(R.mipmap.lock_nor);
                        }

                        startTime();
                        binding.lockButton.setSelected(b);
                    }  SPUtils.setLockStatus(mContext, b);
                }
            });
        }RecordData.getInstance().lockState = b;
        new Thread(new Runnable() {
            @Override
            public void run() {
                LogUtils.d("setLockStatus---b=" + b + ", isRecording=" + isRecording());
                if (isRecording() && recordFileManager != null) {
                    String curRecordFile = recordFileManager.getCurRecordFileName(Config.CHANNEL_BACK);
                    if (curRecordFile != null && curRecordFile.contains("main")) {
                        DriveVideoBack mDriveVideoBack = DBUtil.getBackDriveVideoByName(curRecordFile);
                        if (mDriveVideoBack != null) {mDriveVideoBack.setLockStatus(b);
                            DBUtil.updateBackDriveVideo(mDriveVideoBack);
                            recordFileManager.updateDriveVideo(ConstantsData.TYPE_BACK, mDriveVideoBack.getName(), -1, b);
                        }
                    }
                    curRecordFile = recordFileManager.getCurRecordFileName(Config.CHANNEL_FRONT);
                    if (curRecordFile != null && curRecordFile.contains("sub")) {
                        DriveVideoFont mDriveVideoFont = DBUtil.getFontDriveVideoByName(curRecordFile);
                        if (mDriveVideoFont != null) {mDriveVideoFont.setLockStatus(b);
                            DBUtil.updateFontDriveVideo(mDriveVideoFont);
                            recordFileManager.updateDriveVideo(ConstantsData.TYPE_FRONT, mDriveVideoFont.getName(), -1, b);
                        }
                    }
                } else {
                if (isSensor){
                        String  STR_CHANNEL_FRONT = recordFileManager.getCurRecordFileName(Config.CHANNEL_FRONT);
                        String STR_CHANNEL_BACK = recordFileManager.getCurRecordFileName(Config.CHANNEL_BACK);
                        LogUtils.d(" STR_CHANNEL_FRONT:" + STR_CHANNEL_FRONT + " STR_CHANNEL_BACK:" + STR_CHANNEL_BACK);// /storage/emulated/0/recordVideo/sub/sub_720P_2019-07-01_14-49-19.mp4
                        SPUtils.putString(mContext,Config.STR_CHANNEL_FRONT,STR_CHANNEL_FRONT);
                        SPUtils.putString(mContext,Config.STR_CHANNEL_BACK,STR_CHANNEL_BACK);
                        if (!STR_CHANNEL_FRONT.isEmpty()){
                            LogUtils.d("getVideoList TYPE_FRONT:" + STR_CHANNEL_FRONT);
                            DriveVideoFont mDriveVideoFont = DBUtil.getFontDriveVideoByName(STR_CHANNEL_FRONT);
                            if (mDriveVideoFont != null) {
                                mDriveVideoFont.setLockStatus(true);
                                DBUtil.updateFontDriveVideo(mDriveVideoFont);
                                LogUtils.d("getVideoList ID:" + mDriveVideoFont.getId());
                            }
                            SPUtils.putString(mContext,Config.STR_CHANNEL_FRONT,"");
                        }if (!STR_CHANNEL_BACK.isEmpty()){
                            LogUtils.d("getVideoList TYPE_BACK:" + STR_CHANNEL_BACK);
                            DriveVideoBack mDriveVideoBack = DBUtil.getBackDriveVideoByName(STR_CHANNEL_BACK);
                            if (mDriveVideoBack != null) {
                                mDriveVideoBack.setLockStatus(true);
                                DBUtil.updateBackDriveVideo(mDriveVideoBack);
                            }
                            SPUtils.putString(mContext,Config.STR_CHANNEL_BACK,"");
                        }

                        isSensor = false;
                    } }
            }
        }).start();
    }private View.OnClickListener cameraCutover = new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            LogUtils.d(TAG, "cameraCutover...");
            String display = SystemProperties.get(Stereo.CAMERA_DISPLAY);
            LogUtils.d(TAG, "cameraCutover..."+display);
            if(display.equals(Stereo.CAMERA_DISPLAY_MAIN)){
                SystemProperties.set(Stereo.CAMERA_DISPLAY, Stereo.CAMERA_DISPLAY_SUB);
            }
            if(display.equals(Stereo.CAMERA_DISPLAY_SUB)){
                SystemProperties.set(Stereo.CAMERA_DISPLAY, Stereo.CAMERA_DISPLAY_MAIN);
            }
        }
    };@Override
    public Context getContext() {
        return this;
    }

    public class LocalBinder extends Binder {
        public RecordService getService() {
            return RecordService.this;
        }
    }

    private boolean isDestroy = false;
    //20s
    private int SLEEP_TIME = 1000 * 20;
    private Runnable sleepOff = new Runnable() { @Override
        public void run() {
            LogUtils.e("---sleepOff---开始onDestroy.");
//            onDestroy();
            if (mCameraThread != null) {
                if (mCameraThread.isRecording()) {
                    mCameraThread.stopRecording();
                }
                mCameraThread.close(false);
            }
        }
    }; private final class AccObserver extends ContentObserver {
        public AccObserver(Handler handler) {
            super(handler);
        }

        @Override
        public void onChange(boolean selfChange, Uri uri) {
            boolean accOn = getAccState();
            if (mCurACCStatus == accOn) {
                LogUtils.e("acc AccObserver return same status!" + mCurACCStatus);
                return;
            }
            mCurACCStatus = accOn;
            if (mCameraThread != null) {
                mCameraThread.setCurAccStatus(mCurACCStatus);
            }LogUtils.e("acc off stopRecording :" + accOn);
            if (!accOn) {
                handler.removeCallbacks(sleepOff);
                //开始计时
                handler.postDelayed(sleepOff, SLEEP_TIME);
            } else {
                LogUtils.e("acc on wm=" + wm + ", isDestroy=" + isDestroy);
                handler.removeCallbacks(sleepOff);//检测当前是否处于关闭状态
                if (isDestroy) {
                    if (mCameraThread != null) {
                        if (mCameraThread.getIsBackPreView()) {
                            LogUtils.e("acc on mCameraThread.close isDestroy=" + isDestroy);
                            mCameraThread.close(false);
                        }
                    }
                    onCreate();
                } else {
                if (mCameraThread == null) {
                        LogUtils.e("acc on 未destory .mCameraThread == null");
                        createFloatWindow();
                    } else {
                    handler.post(new Runnable() {
                            @Override
                            public void run() {
                                //还原加锁状态
                                RecordData.getInstance().lockState = SPUtils.getLockStatus(getContext());
                                setLockStatus(RecordData.getInstance().lockState, true);
                            }
                        });
                        mCameraThread.rebootCamera();
                                    }
                }
            }
        }
    }private final class DvrEnableObserver extends ContentObserver {
        public DvrEnableObserver(Handler handler) {
            super(handler);
        }

        @Override
        public void onChange(boolean selfChange, Uri uri) {
            boolean dvrEnable = getDvrEnable();
            LogUtils.e("DvrEnableObserver dvrEnable=" + dvrEnable);
            if (!dvrEnable) {
                REBOOT_SYSTEM = true;
                if(DvrApplication.getPlatform().equals(Config.SYSTEM_PLATFORM_39)){
                    LogUtils.e("DvrEnableObserver ");
                    //open stereo
                    Stereo.callMethodOnObject(Stereo.PROPERTY_KEY_CLIENT_APP_MODE,
                            Stereo.APP_MODE_NAME_MTK_DEFAULT_CAMERA);
                } else { 
                LogUtils.e("DvrEnableObserver 111");
                }
                onDestroy();

                SystemProperties.set(Config.RECORD_WATERMASK, "0");
                SystemProperties.set(Config.RECORD_ENABLE, "0");

                killProcess(getContext(), "com.wwc2.dvr");
            }
        }
    }private final class CameraObserver extends ContentObserver {
        public CameraObserver(Handler handler) {
            super(handler);
        }

        @Override
        public void onChange(boolean selfChange, Uri uri) {
            LogUtils.d("cameraObserver", "selfChange=" + selfChange + ", uri=" + uri);

            //如果正在检测中，不处理。
            if (SYNC_CHECK_CAMERA_NODE || SYNC_REBOOT_CAMERA ||
                    !getAccState()) {//ACC OFF状态不处理。
                LogUtils.d(TAG, "------倒车------当前正在检测中，不处理..." +
                        "SYNC_CHECK_CAMERA_NODE=" + SYNC_CHECK_CAMERA_NODE +
                        ",,SYNC_REBOOT_CAMERA=" + SYNC_REBOOT_CAMERA);
                return;
            }LogUtils.d("getAccState---------->" + getAccState()); //wangp
//            mCameraThread.closeBackCamera();

            checkReversing();
        }
    } private boolean getCameraStatus() {
        boolean ret = false;
        String camera = getContentResolver().getType(uri_camera);
        if (camera != null) {
            ret = camera.equals("true") ? true : false;
        }
        LogUtils.d("getCameraStatus----isReversing=" + ret);
        return ret;
    }/**
     * 杀死指定包名的进程
     */
    public static boolean killProcess(Context context, String packageName) {
        boolean ret = false;
        if (null == context) {
            LogUtils.w(TAG, "#killProcess failed, because the context is null.");
            return ret;
        }
        ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        if (null != am) {
            try {
                LogUtils.d(TAG, "#killProcess packageName = " + packageName);
                Method forceStopPackage = am.getClass().getDeclaredMethod("forceStopPackage", String.class);
                forceStopPackage.setAccessible(true);
                forceStopPackage.invoke(am, packageName);
                ret = true;
} catch (NoSuchMethodException e) {
                LogUtils.w(TAG, "#killProcess failed, because NoSuchMethodException.");
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                LogUtils.w(TAG, "#killProcess failed, because IllegalAccessException.");
                e.printStackTrace();
            } catch (InvocationTargetException e) {
                LogUtils.w(TAG, "#killProcess failed, because InvocationTargetException.");
                e.printStackTrace();
            } catch (Exception e) {
                LogUtils.w(TAG, "#killProcess failed, because Exception.");
                e.printStackTrace();
            } } else {
            LogUtils.w(TAG, "#killProcess failed, because the activity manager is null.");
        }
        return ret;
    }
private BroadcastReceiver mDeviceReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            String path = intent.getData().getPath() + "/";
            int type = StorageDevice.parseFileOrDirName(context,path);//FileUtils.getDeviceId(path);
            int location = RecordData.getInstance().mutableLocation;
            LogUtils.d("DeviceReceiver---action=" + action + ", ID=" + type + ", location=" + location
                    + ", path=" + path);
            LogUtils.d("DeviceReceiver---getAccState=" +  getAccState());
            if (!getAccState()){
                LogUtils.d("<------mDeviceReceiver acc off  不做处理---->");
                return;
            }if (type != -1) {
                if (Intent.ACTION_MEDIA_EJECT.equals(action) ||
                        Intent.ACTION_MEDIA_BAD_REMOVAL.equals(action)) {
                    // 拔出
                    if (type == location) {
                        if (isRecording()) {
                            stopRecording();
                        }

                        if (recordFileDataBase != null) {
                            recordFileDataBase.onDestroy();
                        }
                    }
                    if (recordFileManager != null) {
                        recordFileManager.setUsbMounted(type, false);
                    }
                } else if (Intent.ACTION_MEDIA_MOUNTED.equals(action)) {// 已挂载
                    if (location == type) {
                        recordFileDataBase.onCreate(context);

                        if (!isRecording()) {
                            startRecording();
                        } else {
                            LogUtils.e("ACTION_MEDIA_MOUNTED---isRecording!");
                        }
                    }
                    LogUtils.e("ACTION_MEDIA_MOUNTED---recordFileManager=" + recordFileManager);
                    if (recordFileManager != null) {
                        recordFileManager.setUsbMounted(type, true);
                    }
                } else if (Intent.ACTION_MEDIA_CHECKING.equals(action)) {
                    // 正在检测 暂不作处理
                }
            }
        }
    };private class RecordReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action)) {
                String reason = intent.getStringExtra(SYSTEM_DIALOG_REASON_KEY);
                if (SYSTEM_DIALOG_REASON_HOME_KEY.equalsIgnoreCase(reason)) {
                    //在所有应用界面按home键返回到首页
                    LogUtils.e("home key pressed...isForeGround=" + isForeGround());

                    //倒车中，main会拦截所有按键，无需自行处理

                    if (isForeGround()) {
                        toBackgroundWindow();
                    }
                }}else if (Config.FULL_TYPE.equals(action)){
                setSwitchCamera(false);
            }else if (Config.SPLIT_TYPE.equals(action)){
                setSplitView();
            }else if (Config.SPLIT_TYPE_UP_DOWN.equals(action)){
                LogUtils.d("分屏上下--------------->");
                setSplitUpDownView();

            }else if (Config.ACTION_CRASH.equals(action)){if (mCameraThread != null) {
                    if (isRecording()){
                        File outputFile = FileUtils.getCaptureFile(ConstantsData.PICTURE_DIR, SPUtils.getLocation(getContext())/*location*/);

                        if (outputFile == null) {
                            handler.sendMessageDelayed(handler.obtainMessage(MSG_TAKE_PICTURE), 500);

                        }
                        mCameraThread.captureStill(outputFile.getPath(), Config.CHANNEL_BACK);

                        handler.postDelayed(new Runnable() {
                            @Override
                            public void run() {
                                mCameraThread.captureStill(outputFile.getPath(), Config.CHANNEL_FRONT);
                            }
                        },4000);
                        setLockStatus(true, false);
                    }

                }}else if (Config.SENSOR_TYPE.equals(action)){
                //关闭=0，轻微=1，中等=2，严重=3
                int val = intent.getIntExtra(Config.SENSOR_TYPE_VALUE, Config.SENSOR_CLOSE);
                LogUtils.e("......SENSOR_TYPE...val=" + val);
                switch (val){
                    case 0:
                        Utils.writeTextFile(Config.SENSOR_CLOSE + "", Config.SENSOR_NODE);
                        break;
                    case 1:
                        Utils.writeTextFile(Config.SENSOR_KEY_1 + "", Config.SENSOR_NODE);
                        break;case 2:
                        Utils.writeTextFile(Config.SENSOR_KEY_2 + "", Config.SENSOR_NODE);
                        break;
                    case 3:
                        Utils.writeTextFile(Config.SENSOR_KEY_3 + "", Config.SENSOR_NODE);
                        break;
                }
                String test = Utils.readTextFile(Config.SENSOR_NODE); } else if (action.equals(Config.ACTION_EXIT_DVR)) {
                if (isForeGround()) {
                    LogUtils.d(TAG, "Main: toBackgroundWindow");
                    toBackgroundWindow();
                }
            }else if (action.equals(Config.ACTION_VIDEO_SETTINGS)) {int videoSettingsType = intent.getIntExtra(Config.VIDEO_SETTINGS, Config.VIDEO_SETTINGS_DEFAULT);
                LogUtils.d("接收到视频设置：" + videoSettingsType);//0:单路1  1:单路2   2:双路
                if (videoSettingsType == Config.VIDEO_SETTINGS_SINGLE_1){
                    setOneVideo1();
                }else if (videoSettingsType==Config.VIDEO_SETTINGS_SINGLE){
                    setOneVideo2();
                }else if (videoSettingsType==Config.VIDEO_SETTINGS_DOUBLE){
                    setdoubleVideo();
                }
                mCameraThread.setVideoSettings(videoSettingsType);
            }
        }
    }private void setOneVideo1(){
        RelativeLayout.LayoutParams m_Params = new RelativeLayout.LayoutParams(
                RelativeLayout.LayoutParams.MATCH_PARENT,
                RelativeLayout.LayoutParams.MATCH_PARENT);
        RelativeLayout.LayoutParams w_Params = new RelativeLayout.LayoutParams(
                0,0);
        DvrApplication.setCHANNELS(Config.CHANNEL_BACK);
        binding.cameraViewBack.setLayoutParams(m_Params);
        binding.cameraViewFront.setLayoutParams(w_Params);

        binding.cameraViewBack.setZOrderOnTop(false);
        binding.cameraViewFront.setZOrderOnTop(true);

    } private void setOneVideo2(){
        RelativeLayout.LayoutParams m_Params = new RelativeLayout.LayoutParams(
                RelativeLayout.LayoutParams.MATCH_PARENT,
                RelativeLayout.LayoutParams.MATCH_PARENT);
        RelativeLayout.LayoutParams w_Params = new RelativeLayout.LayoutParams(
                0,0);
        DvrApplication.setCHANNELS(Config.CHANNEL_FRONT);
        binding.cameraViewFront.setLayoutParams(m_Params);
        binding.cameraViewBack.setLayoutParams(w_Params);
        binding.cameraViewBack.setZOrderOnTop(true);
        binding.cameraViewFront.setZOrderOnTop(false);
    }private void setdoubleVideo(){
        LogUtils.d("双录视频设置,判断是否是设置过分屏");
        int  isSplit = SPUtils.getSplitScreen(getContext());
        if (isSplit ==Config.SPLIT_SCREEN){
            setSplitView();
        }else if (isSplit ==Config.SPLIT_SCREEN_UP_DOWN){
            setSplitUpDownView();
        }else {
            setSwitchCamera(false);
        }
    }
    private void setSplitView(){
        Display defaultDisplay = wm.getDefaultDisplay();
        Point point = new Point();
        defaultDisplay.getSize(point);
        int x = point.x;
        int y = point.y;
        int w = x/2;
        int h = (int) (y*0.6);
        int top = y/2 - h/2;

        LogUtils.d("WPTAG","X----->"  + x);
        RelativeLayout.LayoutParams back_Params = new RelativeLayout.LayoutParams(w, h);
        RelativeLayout.LayoutParams front_Params = new RelativeLayout.LayoutParams(w - 1, h);

        front_Params.addRule(RelativeLayout.ALIGN_PARENT_LEFT);
        front_Params.setMargins(0, top,0,0);
        back_Params.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);
        back_Params.setMargins(0, top,0,0);

        binding.cameraViewBack.setLayoutParams(back_Params);
        binding.cameraViewFront.setLayoutParams(front_Params);
        binding.cameraViewFront.setClickable(false);
        binding.cameraViewBack.setClickable(false);
    }
    private void setSplitUpDownView(){
        Display defaultDisplay = wm.getDefaultDisplay();
        Point point = new Point();
        defaultDisplay.getSize(point);
        int x = point.x;
        int y = point.y;
        int h = y/2;
        int w = x;
        int top = y/2 - h/2;

        LogUtils.d("WPTAG","X----->"  + x);
        RelativeLayout.LayoutParams back_Params = new RelativeLayout.LayoutParams(w, h);
        RelativeLayout.LayoutParams front_Params = new RelativeLayout.LayoutParams(w, h - 1);

        front_Params.addRule(RelativeLayout.ALIGN_PARENT_TOP);
        front_Params.setMargins(0,0 ,0,top);
        back_Params.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
        back_Params.setMargins(0, top,0,0); binding.cameraViewBack.setLayoutParams(back_Params);
        binding.cameraViewFront.setLayoutParams(front_Params);
        binding.cameraViewFront.setClickable(false);
        binding.cameraViewBack.setClickable(false);

        binding.cameraViewBack.setZOrderOnTop(false);
        binding.cameraViewFront.setZOrderOnTop(false);

    }
private void setSwitchCamera(boolean flag) {
        int videoSettingsType = SPUtils.getVideoSettings(getContext());//1：单录 2:双录
        LogUtils.d("setSwitchCamera 当前视频模式为:" + videoSettingsType);
        RelativeLayout.LayoutParams m_Params = null;
        RelativeLayout.LayoutParams w_Params = null;
        LogUtils.d("setSwitchCamera 当前平台为:" + DvrApplication.getPlatform());
        if (DvrApplication.getPlatform().equals(Config.SYSTEM_PLATFORM_63) ||DvrApplication.getPlatform().equals(Config.SYSTEM_PLATFORM_65) ){

            if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE_1){saveVideoSettings(Config.VIDEO_INPUT_VALUE_MAIN_B_SUB_A,Config.VIDEO_INPUT_KEY_MAIN_B_SUB_A);
                Utils.writeTextFile(Config.HD  + Config.FHD, Config.CAMERA_360_TYPE_NODE);
                RecordData.getInstance().cameraType.setValue(Config.HD  + Config.FHD);
                SPUtils.putString(getContext(), Config.CAMERA_VALUE, Config.HD  + Config.FHD);

                m_Params = new RelativeLayout.LayoutParams(
                        RelativeLayout.LayoutParams.MATCH_PARENT,
                        RelativeLayout.LayoutParams.MATCH_PARENT);
                w_Params = new RelativeLayout.LayoutParams(
                        0, 0);boolean status =  getCameraStatus();
                LogUtils.d("setSwitchCamera------status ==" +  status);
                i = 100;
                mCameraThread.rebootCamera();


            }else  if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE){
                m_Params = new RelativeLayout.LayoutParams(
                        RelativeLayout.LayoutParams.MATCH_PARENT,
                        RelativeLayout.LayoutParams.MATCH_PARENT);
                w_Params = new RelativeLayout.LayoutParams(
                        0, 0);  boolean isBackOpened =   mCameraThread.isCameraBackOpened();
                LogUtils.d("setSwitchCamera   ---------isBackOpened:" + isBackOpened );
                if (isBackOpened){
                    LogUtils.d("单录时如果后摄已打开，开始关闭后摄"  + !getCameraStatus());
                    if (!getCameraStatus()){
                        mCameraThread.closeBackCamera(); }else if (videoSettingsType ==Config.VIDEO_SETTINGS_DOUBLE){
                m_Params = new RelativeLayout.LayoutParams(
                        RelativeLayout.LayoutParams.MATCH_PARENT,
                        RelativeLayout.LayoutParams.MATCH_PARENT);
                w_Params = new RelativeLayout.LayoutParams(
                        DEF_WIDTH, DEF_HEIGHT);
            }
        } else {
            //其他平台由底层切换
            LogUtils.e("setSwitchCamera---no support!");
            return;
        }if (flag){
            binding.cameraViewFront.setZOrderOnTop(false);
            binding.cameraViewBack.setZOrderOnTop(true);
            binding.cameraViewBack.setTop(1);
            binding.cameraViewFront.setTop(0);
            binding.cameraViewFront.setLayoutParams(m_Params);
            binding.cameraViewBack.setLayoutParams(w_Params);
            if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE){
                binding.cameraViewBack.setClickable(false);
            }else {
                binding.cameraViewBack.setClickable(true);
            } binding.cameraViewFront.setClickable(false);
            DvrApplication.setCHANNELS(Config.CHANNEL_FRONT);
        }else {
            binding.cameraViewFront.setZOrderOnTop(true);
            binding.cameraViewFront.setTop(1);
            binding.cameraViewFront.setLayoutParams(w_Params);
            binding.cameraViewBack.setZOrderOnTop(false);
            binding.cameraViewBack.setTop(0);
            binding.cameraViewBack.setLayoutParams(m_Params);
            binding.cameraViewFront.setClickable(true);
            binding.cameraViewBack.setClickable(false);
            DvrApplication.setCHANNELS(Config.CHANNEL_BACK);
        }
    }/**
     * 开始自动检测
     * @param view
     */
    @Override
    public void btnCheckClick(View view) {

        setCameraInfo(1);
        handler.sendEmptyMessageDelayed(Config.MSG_CHECK_TIMER, Config.DELAY_TIME / 4);
    }/**
     * 取消自动检测
     * @param view
     */
    @Override
    public void btnCancelClick(View view) {
//        btnCheckClick  btn_cancel

        SYNC_CHECK_CAMERA_NODE = false;
        LogUtils.e("btnCancelClick......取消自动检测..释放锁SYNC_CHECK_CAMERA_NODE="
                + SYNC_CHECK_CAMERA_NODE);

        binding.layoutCheckCamera.setVisibility(View.GONE);
         }

    String preDisplay = null;
    private void checkReversing(){
        //检测倒车状态
        String main = SPUtils.getString(getContext(), Config.VIDEO_KEY, "_A");
        LogUtils.d(TAG, "----------main=" + main + "getCameraStatus:" + getCameraStatus());
        String sw = main.substring(main.indexOf("_") +1, main.indexOf("_") +2);
        LogUtils.d(TAG, "----------sw=" + sw + ", preDisplay=" + preDisplay);
        if (getCameraStatus()) {
            switchReversing();
            setTrackView();
            //切倒车
            if (sw.equals("B")) {
                LogUtils.d("checkReversing-切倒车---" );toBackgroundWindow();
                FileUtils.writeTextFile(Config.CAMERA_A,
                        Config.CAMERA_SWITCH_NODE);
                handler.postDelayed(new Runnable() {
                    @Override
                    public void run() {
                            toForegroundWindow();

                    }
                }, 2500);//wangpeng
            }
        } else {   i = 100;
            if (preDisplay != null) {
                if (sw.equals("B")) {
                    FileUtils.writeTextFile(Config.CAMERA_B,
                            Config.CAMERA_SWITCH_NODE);
                }
                switchDVR();
            } else {
                LogUtils.e(TAG, "...checkReversing...preDisplay=null");

            }
        }
    }
     @Override
    public  void saveOkClick(View view){

        //节点锁已释放..
        SYNC_CHECK_CAMERA_NODE = false;
        LogUtils.e("saveOkClick......确定保存!...释放节点锁.");
        handler.sendEmptyMessage(Config.MSG_WRITE_TIMER);
    }
     @Override
    public void saveNoClick(View view){
        LogUtils.e("saveNoClick......取消，不保存!...释放节点锁.");

        //节点锁已释放..
        SYNC_CHECK_CAMERA_NODE = false;
        binding.layoutCheckCamera.setVisibility(View.GONE);

        //开启loading
        syncLoading(true);

        handler.post(new Runnable() {
            @Override
            public void run() {
                mCameraThread.rebootCamera();
            }
        });
    } 
    private boolean isSensor = false;
    public String postSensor(boolean isOff, boolean syncStatus){
        LogUtils.e("postSensor...isOff=" + isOff + ",,syncStatus=" + syncStatus);
        if (mCameraThread == null) {
            LogUtils.e("postSensor...mCameraThread == null");
            return "";
        }
        isSensor = true;

        if (syncStatus) {
         setLockStatus(true, false);//里面有判断是否在录制中
        } else {if (getAccState()) {//ACC ON状态碰撞后需要还原加锁状态
                handler.post(new Runnable() {
                    @Override
                    public void run() {
                        //还原加锁状态
                        RecordData.getInstance().lockState = SPUtils.getLockStatus(getContext());
                    }
                });
            }
//            setLockStatus(false);
        }
        return "";
    }
    public void updateSensor(){
        LogUtils.e("...updateSensor...");
        String serial = getContentResolver().getType(caruri);
        LogUtils.d(TAG, "updateSensor...serial=" + serial);
        if(!TextUtils.isEmpty(serial)){
            int sensor = 0;
            try {
                sensor = Integer.parseInt(serial);
            } catch (NumberFormatException e) {
                e.printStackTrace();
            }
            switch (sensor){
            case 0:
                    sensor = Config.SENSOR_CLOSE;
                    break;
                case 1:
                    sensor = Config.SENSOR_KEY_1;
                    break;
                case 2:
                    sensor = Config.SENSOR_KEY_2;
                    break;
                case 3:
                    sensor = Config.SENSOR_KEY_3;
                    break;
            }SPUtils.setSensor(getContext(), sensor);
            RecordData.getInstance().sensor.postValue(sensor);
            Utils.writeTextFile(sensor + "", Config.SENSOR_NODE);

            String test = Utils.readTextFile(Config.SENSOR_NODE);
            LogUtils.e("......updateSensor...test=" + test);
        }
    }
     private int cameraCheckState = 0;
    private int cameraMainType = -1;
    private int cameraSubType = -1;
    private String strAutoCheckCameraText = "";
    private String strAutoCheckCameratype = "";
    private String strAutoCheckCameratypeValue = "";
    protected void setCameraInfo(int index) {
        if (floatView == null) {
            return;
        }
         LinearLayout rlSuccess = binding.rlCheckSuccess;
        TextView infoText = binding.tvCheckInfo;
        Button btnCheck = binding.btnCheck;
        Button btnCancel =  binding.btnCancel;

        if (rlSuccess == null || infoText == null) {
            return;
        }
        cameraCheckState = index;
        switch (index) {
            case 1:
                infoText.setText(getContext().getResources().getString(R.string.checking));
                btnCheck.setVisibility(View.GONE);
                btnCancel.setVisibility(View.GONE);
                break;
            case 2:
                String info = "";
                info = getContext().getResources().getString(R.string.check_success);
                LogUtils.e("setCameraInfo......cameraMainType=" + cameraMainType
                    + ",,cameraSubType=" + cameraSubType);
                if (cameraMainType >= 0 && cameraMainType < 50
                    && cameraSubType >= 0 && cameraSubType < 50) {

                    info += strAutoCheckCameraText;
                    info += getContext().getResources().getString(R.string.save_ask);

                    rlSuccess.setVisibility(View.VISIBLE);
                    btnCancel.setVisibility(View.GONE);
                    btnCheck.setVisibility(View.GONE);
                    } else {
                    btnCheck.setVisibility(View.VISIBLE);
                    btnCancel.setVisibility(View.VISIBLE);
                    rlSuccess.setVisibility(View.GONE);

                    if (cameraMainType == Config.CAM_TYPE_UNKNOW &&
                            cameraSubType == Config.CAM_TYPE_UNKNOW) {
                        info = getContext().getResources().getString(R.string.CAM_TYPE_UNKNOW);
                    } else if ((cameraMainType == Config.CAM_NO_SIGNAL ||
                            cameraMainType == Config.CAM_HARDWARE_ERROR)
                            && (cameraSubType == Config.CAM_NO_SIGNAL ||
                            cameraSubType == Config.CAM_HARDWARE_ERROR)) {
                            nfo = getContext().getResources().getString(R.string.CAM_NO_SIGNAL);
//                    } else if (cameraType == 52) {
//                        info = mContext.getResources().getString(R.string.CAM_HARDWARE_ERROR);
                    } else if (cameraMainType == Config.CAMERA_ERROR
                            || cameraSubType == Config.CAMERA_ERROR) {

                        //摄像头启动失败
                        info = getContext().getResources().getString(R.string.check_error);

                    }else if (cameraMainType == Config.CAM_NO_SIGNAL){ //006单录单芯片
                        info = strAutoCheckCameraText + "，";
                        info += getContext().getResources().getString(R.string.CAM_ERR);
}else if (cameraMainType ==Config.CAM_TYPE_UNKNOW){
                        info = strAutoCheckCameraText + "，";
                        info += getContext().getResources().getString(R.string.CAM_ERR);
                    }else {
                        int videoSettingsType =  SPUtils.getVideoSettings(getContext());//1：单录 2:双录
                        if (videoSettingsType ==Config.VIDEO_SETTINGS_SINGLE){
                            info += strAutoCheckCameraText;
                            info += getContext().getResources().getString(R.string.save_ask);
                            rlSuccess.setVisibility(View.VISIBLE);
                            btnCancel.setVisibility(View.GONE);
                            btnCheck.setVisibility(View.GONE);}else if (videoSettingsType ==Config.VIDEO_SETTINGS_DOUBLE){
                            info = strAutoCheckCameraText + "，";
                            info += getContext().getResources().getString(R.string.CAM_ERR);
                        }
                        LogUtils.d("---setCameraInfo--info=" + info);
                    }
                }
                infoText.setText(info);
                break; 
                case 3:
                infoText.setText(getContext().getString(R.string.saving));
                btnCheck.setVisibility(View.GONE);
                rlSuccess.setVisibility(View.GONE);
                break;
            case 4:
                infoText.setText(getContext().getString(R.string.write_ok));
                btnCheck.setVisibility(View.GONE);
                rlSuccess.setVisibility(View.GONE);
                binding.ivTrack.setVisibility(View.GONE);

                break;
                 case 6 :
                btnCheck.setVisibility(View.VISIBLE);
                btnCancel.setVisibility(View.VISIBLE);
                rlSuccess.setVisibility(View.GONE);
                infoText.setText(getContext().getResources().getString(R.string.CAM_TYPE_UNKNOW));
            default:
                String string = getContext().getResources().getString(R.string.check_warn_info_check);
                infoText.setText(string);
                btnCheck.setVisibility(View.VISIBLE);
                rlSuccess.setVisibility(View.GONE);
                break;
        }
    }  public interface SerListener {
        void onBackground();
    }

    SerListener activitylistener;
    public void setSerListener(SerListener listener){
        if(listener != null){
            activitylistener = listener;
        }
    }

    public static boolean getCurAccStatus() {
        return mCurACCStatus;
    }
}
